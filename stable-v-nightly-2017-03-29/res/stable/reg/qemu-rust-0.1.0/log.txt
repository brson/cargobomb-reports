boom! testing qemu-rust-0.1.0 against stable for nightly
boom! running: cargo +stable build --frozen
boom! creating container for: cargo +stable build --frozen
boom! running `docker create -v /home/ec2-user/cargobomb/./work/local/test-source/nightly/stable:/source:ro -v /home/ec2-user/cargobomb/./work/local/cargo-home:/cargo-home:ro -v /home/ec2-user/cargobomb/./work/local/rustup-home:/rustup-home:ro -v /home/ec2-user/cargobomb/./work/local/target-dirs/nightly/stable:/target:rw -e USER_ID=500 -e CMD=cargo +stable build --frozen cargobomb`
blam! 99041e924a99ae69f35f07e9aa57c2676e33485db11ba731f3d465a919f3b22c
boom! running `docker start -a 99041e924a99ae69f35f07e9aa57c2676e33485db11ba731f3d465a919f3b22c`
kablam!    Compiling parse_qapi v0.1.2
kablam!    Compiling qemu-rust v0.1.0 (file:///source)
kablam! warning: unused `#[macro_use]` import, #[warn(unused_imports)] on by default
kablam!  --> build.rs:3:1
kablam!   |
kablam! 3 | #[macro_use] extern crate nom;
kablam!   | ^^^^^^^^^^^^
kablam! 
kablam! error: failed to run custom build command for `qemu-rust v0.1.0 (file:///source)`
kablam! process didn't exit successfully: `/target/debug/build/qemu-rust-e6012144314686da/build-script-build` (exit code: 101)
kablam! --- stdout
kablam! 2017-03-27 02:54:59 DEBUG [hyper::net] http scheme
kablam! 2017-03-27 02:55:00 DEBUG [hyper::http::h1] request line: Get "/qemu/qmp-unstable.git/blob_plain/refs/heads/master:/qapi/block.json" Http11
kablam! 2017-03-27 02:55:00 DEBUG [hyper::http::h1] headers=Headers { Host: repo.or.cz
kablam! , Connection: close
kablam! , }
kablam! 2017-03-27 02:55:00 DEBUG [hyper::client::response] version=Http11, status=Ok
kablam! 2017-03-27 02:55:00 DEBUG [hyper::client::response] headers=Headers { Date: Mon, 27 Mar 2017 02:55:00 GMT
kablam! , Server: Apache
kablam! , Content-disposition: inline; filename="qapi/block.json"
kablam! , Connection: close
kablam! , Transfer-Encoding: chunked
kablam! , Content-Type: application/json; charset=ISO-8859-1
kablam! , }
kablam! 2017-03-27 02:55:00 DEBUG [hyper::net] http scheme
kablam! 2017-03-27 02:55:00 DEBUG [hyper::http::h1] request line: Get "/qemu/qmp-unstable.git/blob_plain/refs/heads/master:/qapi/block-core.json" Http11
kablam! 2017-03-27 02:55:00 DEBUG [hyper::http::h1] headers=Headers { Host: repo.or.cz
kablam! , Connection: close
kablam! , }
kablam! 2017-03-27 02:55:00 DEBUG [hyper::client::response] version=Http11, status=Ok
kablam! 2017-03-27 02:55:00 DEBUG [hyper::client::response] headers=Headers { Date: Mon, 27 Mar 2017 02:55:00 GMT
kablam! , Server: Apache
kablam! , Content-disposition: inline; filename="qapi/block-core.json"
kablam! , Connection: close
kablam! , Transfer-Encoding: chunked
kablam! , Content-Type: application/json; charset=ISO-8859-1
kablam! , }
kablam! 2017-03-27 02:55:02 DEBUG [hyper::net] http scheme
kablam! 2017-03-27 02:55:02 DEBUG [hyper::http::h1] request line: Get "/qemu/qmp-unstable.git/blob_plain/refs/heads/master:/qapi/common.json" Http11
kablam! 2017-03-27 02:55:02 DEBUG [hyper::http::h1] headers=Headers { Host: repo.or.cz
kablam! , Connection: close
kablam! , }
kablam! 2017-03-27 02:55:02 DEBUG [hyper::client::response] version=Http11, status=Ok
kablam! 2017-03-27 02:55:02 DEBUG [hyper::client::response] headers=Headers { Date: Mon, 27 Mar 2017 02:55:02 GMT
kablam! , Server: Apache
kablam! , Content-disposition: inline; filename="qapi/common.json"
kablam! , Connection: close
kablam! , Transfer-Encoding: chunked
kablam! , Content-Type: application/json; charset=ISO-8859-1
kablam! , }
kablam! 2017-03-27 02:55:02 DEBUG [hyper::net] http scheme
kablam! 2017-03-27 02:55:02 DEBUG [hyper::http::h1] request line: Get "/qemu/qmp-unstable.git/blob_plain/refs/heads/master:/qapi/trace.json" Http11
kablam! 2017-03-27 02:55:02 DEBUG [hyper::http::h1] headers=Headers { Host: repo.or.cz
kablam! , Connection: close
kablam! , }
kablam! 2017-03-27 02:55:02 DEBUG [hyper::client::response] version=Http11, status=Ok
kablam! 2017-03-27 02:55:02 DEBUG [hyper::client::response] headers=Headers { Date: Mon, 27 Mar 2017 02:55:02 GMT
kablam! , Server: Apache
kablam! , Content-disposition: inline; filename="qapi/trace.json"
kablam! , Connection: close
kablam! , Transfer-Encoding: chunked
kablam! , Content-Type: application/json; charset=ISO-8859-1
kablam! , }
kablam! 2017-03-27 02:55:02 DEBUG [hyper::net] http scheme
kablam! 2017-03-27 02:55:02 DEBUG [hyper::http::h1] request line: Get "/qemu/qmp-unstable.git/blob_plain/refs/heads/master:/qapi/event.json" Http11
kablam! 2017-03-27 02:55:02 DEBUG [hyper::http::h1] headers=Headers { Host: repo.or.cz
kablam! , Connection: close
kablam! , }
kablam! 2017-03-27 02:55:03 DEBUG [hyper::client::response] version=Http11, status=Ok
kablam! 2017-03-27 02:55:03 DEBUG [hyper::client::response] headers=Headers { Date: Mon, 27 Mar 2017 02:55:03 GMT
kablam! , Server: Apache
kablam! , Content-disposition: inline; filename="qapi/event.json"
kablam! , Connection: close
kablam! , Transfer-Encoding: chunked
kablam! , Content-Type: application/json; charset=ISO-8859-1
kablam! , }
kablam! 2017-03-27 02:55:03 DEBUG [hyper::net] http scheme
kablam! 2017-03-27 02:55:03 DEBUG [hyper::http::h1] request line: Get "/w/qemu/qmp-unstable.git/blob_plain/HEAD:/qapi-schema.json" Http11
kablam! 2017-03-27 02:55:03 DEBUG [hyper::http::h1] headers=Headers { Host: repo.or.cz
kablam! , Connection: close
kablam! , }
kablam! 2017-03-27 02:55:03 DEBUG [hyper::client::response] version=Http11, status=Ok
kablam! 2017-03-27 02:55:03 DEBUG [hyper::client::response] headers=Headers { Date: Mon, 27 Mar 2017 02:55:03 GMT
kablam! , Server: Apache
kablam! , Content-disposition: inline; filename="qapi-schema.json"
kablam! , Connection: close
kablam! , Transfer-Encoding: chunked
kablam! , Content-Type: application/json; charset=ISO-8859-1
kablam! , }
kablam! Json result: Ok(Object({"include": String("block-core.json")}))
kablam! Json result: Ok(Object({"data": Array([String("auto"), String("none"), String("lba"), String("large"), String("rechs")]), "enum": String("BiosAtaTranslation")}))
kablam! Json result: Ok(Object({"data": Object({"device": String("str"), "name": String("str")}), "struct": String("BlockdevSnapshotInternal")}))
kablam! Json result: Ok(Object({"command": String("blockdev-snapshot-internal-sync"), "data": String("BlockdevSnapshotInternal")}))
kablam! Json result: Ok(Object({"command": String("blockdev-snapshot-delete-internal-sync"), "data": Object({"*id": String("str"), "*name": String("str"), "device": String("str")}), "returns": String("SnapshotInfo")}))
kablam! Json result: Ok(Object({"command": String("eject"), "data": Object({"*force": String("bool"), "device": String("str")})}))
kablam! Json result: Ok(Object({"command": String("nbd-server-start"), "data": Object({"addr": String("SocketAddress")})}))
kablam! Json result: Ok(Object({"command": String("nbd-server-add"), "data": Object({"*writable": String("bool"), "device": String("str")})}))
kablam! Json result: Ok(Object({"command": String("nbd-server-stop")}))
kablam! Json result: Ok(Object({"data": Object({"device": String("str"), "tray-open": String("bool")}), "event": String("DEVICE_TRAY_MOVED")}))
kablam! Json result: Ok(Object({"include": String("common.json")}))
kablam! Json result: Ok(Object({"data": Object({"date-nsec": String("int"), "date-sec": String("int"), "id": String("str"), "name": String("str"), "vm-clock-nsec": String("int"), "vm-clock-sec": String("int"), "vm-state-size": String("int")}), "struct": String("SnapshotInfo")}))
kablam! Json result: Ok(Object({"data": Object({"*corrupt": String("bool"), "*lazy-refcounts": String("bool"), "compat": String("str"), "refcount-bits": String("int")}), "struct": String("ImageInfoSpecificQCow2")}))
kablam! Json result: Ok(Object({"data": Object({"cid": String("int"), "create-type": String("str"), "extents": Array([String("ImageInfo")]), "parent-cid": String("int")}), "struct": String("ImageInfoSpecificVmdk")}))
kablam! Json result: Ok(Object({"data": Object({"qcow2": String("ImageInfoSpecificQCow2"), "vmdk": String("ImageInfoSpecificVmdk")}), "union": String("ImageInfoSpecific")}))
kablam! Json result: Ok(Object({"data": Object({"*actual-size": String("int"), "*backing-filename": String("str"), "*backing-filename-format": String("str"), "*backing-image": String("ImageInfo"), "*cluster-size": String("int"), "*compressed": String("bool"), "*dirty-flag": String("bool"), "*encrypted": String("bool"), "*format-specific": String("ImageInfoSpecific"), "*full-backing-filename": String("str"), "*snapshots": Array([String("SnapshotInfo")]), "filename": String("str"), "format": String("str"), "virtual-size": String("int")}), "struct": String("ImageInfo")}))
kablam! Json result: Ok(Object({"data": Object({"*allocated-clusters": String("int"), "*compressed-clusters": String("int"), "*corruptions": String("int"), "*corruptions-fixed": String("int"), "*fragmented-clusters": String("int"), "*image-end-offset": String("int"), "*leaks": String("int"), "*leaks-fixed": String("int"), "*total-clusters": String("int"), "check-errors": String("int"), "filename": String("str"), "format": String("str")}), "struct": String("ImageCheck")}))
kablam! Json result: Ok(Object({"data": Object({"direct": String("bool"), "no-flush": String("bool"), "writeback": String("bool")}), "struct": String("BlockdevCacheInfo")}))
kablam! Json result: Ok(Object({"data": Object({"*backing_file": String("str"), "*bps_max": String("int"), "*bps_rd_max": String("int"), "*bps_wr_max": String("int"), "*iops_max": String("int"), "*iops_rd_max": String("int"), "*iops_size": String("int"), "*iops_wr_max": String("int"), "*node-name": String("str"), "backing_file_depth": String("int"), "bps": String("int"), "bps_rd": String("int"), "bps_wr": String("int"), "cache": String("BlockdevCacheInfo"), "detect_zeroes": String("BlockdevDetectZeroesOptions"), "drv": String("str"), "encrypted": String("bool"), "encryption_key_missing": String("bool"), "file": String("str"), "image": String("ImageInfo"), "iops": String("int"), "iops_rd": String("int"), "iops_wr": String("int"), "ro": String("bool"), "write_threshold": String("int")}), "struct": String("BlockDeviceInfo")}))
kablam! Json result: Ok(Object({"data": Array([String("ok"), String("failed"), String("nospace")]), "enum": String("BlockDeviceIoStatus")}))
kablam! Json result: Ok(Object({"data": Object({"*offset": String("int"), "data": String("bool"), "depth": String("int"), "length": String("int"), "start": String("int"), "zero": String("bool")}), "struct": String("BlockDeviceMapEntry")}))
kablam! Json result: Ok(Object({"data": Object({"*name": String("str"), "count": String("int"), "frozen": String("bool"), "granularity": String("uint32")}), "struct": String("BlockDirtyInfo")}))
kablam! Json result: Ok(Object({"data": Object({"*dirty-bitmaps": Array([String("BlockDirtyInfo")]), "*inserted": String("BlockDeviceInfo"), "*io-status": String("BlockDeviceIoStatus"), "*tray_open": String("bool"), "device": String("str"), "locked": String("bool"), "removable": String("bool"), "type": String("str")}), "struct": String("BlockInfo")}))
kablam! Json result: Ok(Object({"command": String("query-block"), "returns": Array([String("BlockInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"flush_operations": String("int"), "flush_total_time_ns": String("int"), "rd_bytes": String("int"), "rd_merged": String("int"), "rd_operations": String("int"), "rd_total_time_ns": String("int"), "wr_bytes": String("int"), "wr_highest_offset": String("int"), "wr_merged": String("int"), "wr_operations": String("int"), "wr_total_time_ns": String("int")}), "struct": String("BlockDeviceStats")}))
kablam! Json result: Ok(Object({"data": Object({"*backing": String("BlockStats"), "*device": String("str"), "*node-name": String("str"), "*parent": String("BlockStats"), "stats": String("BlockDeviceStats")}), "struct": String("BlockStats")}))
kablam! Json result: Ok(Object({"command": String("query-blockstats"), "data": Object({"*query-nodes": String("bool")}), "returns": Array([String("BlockStats")])}))
kablam! Json result: Ok(Object({"data": Array([String("report"), String("ignore"), String("enospc"), String("stop")]), "enum": String("BlockdevOnError")}))
kablam! Json result: Ok(Object({"data": Array([String("top"), String("full"), String("none"), String("dirty-bitmap")]), "enum": String("MirrorSyncMode")}))
kablam! Json result: Ok(Object({"data": Array([String("commit"), String("stream"), String("mirror"), String("backup")]), "enum": String("BlockJobType")}))
kablam! Json result: Ok(Object({"data": Object({"busy": String("bool"), "device": String("str"), "io-status": String("BlockDeviceIoStatus"), "len": String("int"), "offset": String("int"), "paused": String("bool"), "ready": String("bool"), "speed": String("int"), "type": String("str")}), "struct": String("BlockJobInfo")}))
kablam! Json result: Ok(Object({"command": String("query-block-jobs"), "returns": Array([String("BlockJobInfo")])}))
kablam! Json result: Ok(Object({"command": String("block_passwd"), "data": Object({"*device": String("str"), "*node-name": String("str"), "password": String("str")})}))
kablam! Json result: Ok(Object({"command": String("block_resize"), "data": Object({"*device": String("str"), "*node-name": String("str"), "size": String("int")})}))
kablam! Json result: Ok(Object({"data": Array([String("existing"), String("absolute-paths")]), "enum": String("NewImageMode")}))
kablam! Json result: Ok(Object({"data": Object({"*device": String("str"), "*format": String("str"), "*mode": String("NewImageMode"), "*node-name": String("str"), "*snapshot-node-name": String("str"), "snapshot-file": String("str")}), "struct": String("BlockdevSnapshot")}))
kablam! Json result: Ok(Object({"data": Object({"*bitmap": String("str"), "*format": String("str"), "*mode": String("NewImageMode"), "*on-source-error": String("BlockdevOnError"), "*on-target-error": String("BlockdevOnError"), "*speed": String("int"), "device": String("str"), "sync": String("MirrorSyncMode"), "target": String("str")}), "struct": String("DriveBackup")}))
kablam! Json result: Ok(Object({"data": Object({"*on-source-error": String("BlockdevOnError"), "*on-target-error": String("BlockdevOnError"), "*speed": String("int"), "device": String("str"), "sync": String("MirrorSyncMode"), "target": String("str")}), "struct": String("BlockdevBackup")}))
kablam! Json result: Ok(Object({"command": String("blockdev-snapshot-sync"), "data": String("BlockdevSnapshot")}))
kablam! Json result: Ok(Object({"command": String("change-backing-file"), "data": Object({"backing-file": String("str"), "device": String("str"), "image-node-name": String("str")})}))
kablam! Json result: Ok(Object({"command": String("block-commit"), "data": Object({"*backing-file": String("str"), "*base": String("str"), "*speed": String("int"), "*top": String("str"), "device": String("str")})}))
kablam! Json result: Ok(Object({"command": String("drive-backup"), "data": String("DriveBackup")}))
kablam! Json result: Ok(Object({"command": String("blockdev-backup"), "data": String("BlockdevBackup")}))
kablam! Json result: Ok(Object({"command": String("query-named-block-nodes"), "returns": Array([String("BlockDeviceInfo")])}))
kablam! Json result: Ok(Object({"command": String("drive-mirror"), "data": Object({"*buf-size": String("int"), "*format": String("str"), "*granularity": String("uint32"), "*mode": String("NewImageMode"), "*node-name": String("str"), "*on-source-error": String("BlockdevOnError"), "*on-target-error": String("BlockdevOnError"), "*replaces": String("str"), "*speed": String("int"), "device": String("str"), "sync": String("MirrorSyncMode"), "target": String("str")})}))
kablam! Json result: Ok(Object({"data": Object({"name": String("str"), "node": String("str")}), "struct": String("BlockDirtyBitmap")}))
kablam! Json result: Ok(Object({"data": Object({"*granularity": String("uint32"), "name": String("str"), "node": String("str")}), "struct": String("BlockDirtyBitmapAdd")}))
kablam! Json result: Ok(Object({"command": String("block-dirty-bitmap-add"), "data": String("BlockDirtyBitmapAdd")}))
kablam! Json result: Ok(Object({"command": String("block-dirty-bitmap-remove"), "data": String("BlockDirtyBitmap")}))
kablam! Json result: Ok(Object({"command": String("block-dirty-bitmap-clear"), "data": String("BlockDirtyBitmap")}))
kablam! Json result: Ok(Object({"command": String("block_set_io_throttle"), "data": Object({"*bps_max": String("int"), "*bps_rd_max": String("int"), "*bps_wr_max": String("int"), "*iops_max": String("int"), "*iops_rd_max": String("int"), "*iops_size": String("int"), "*iops_wr_max": String("int"), "bps": String("int"), "bps_rd": String("int"), "bps_wr": String("int"), "device": String("str"), "iops": String("int"), "iops_rd": String("int"), "iops_wr": String("int")})}))
kablam! Json result: Ok(Object({"command": String("block-stream"), "data": Object({"*backing-file": String("str"), "*base": String("str"), "*on-error": String("BlockdevOnError"), "*speed": String("int"), "device": String("str")})}))
kablam! Json result: Ok(Object({"command": String("block-job-set-speed"), "data": Object({"device": String("str"), "speed": String("int")})}))
kablam! Json result: Ok(Object({"command": String("block-job-cancel"), "data": Object({"*force": String("bool"), "device": String("str")})}))
kablam! Json result: Ok(Object({"command": String("block-job-pause"), "data": Object({"device": String("str")})}))
kablam! Json result: Ok(Object({"command": String("block-job-resume"), "data": Object({"device": String("str")})}))
kablam! Json result: Ok(Object({"command": String("block-job-complete"), "data": Object({"device": String("str")})}))
kablam! Json result: Ok(Object({"data": Array([String("ignore"), String("unmap")]), "enum": String("BlockdevDiscardOptions")}))
kablam! Json result: Ok(Object({"data": Array([String("off"), String("on"), String("unmap")]), "enum": String("BlockdevDetectZeroesOptions")}))
kablam! Json result: Ok(Object({"data": Array([String("threads"), String("native")]), "enum": String("BlockdevAioOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*direct": String("bool"), "*no-flush": String("bool"), "*writeback": String("bool")}), "struct": String("BlockdevCacheOptions")}))
kablam! Json result: Ok(Object({"data": Array([String("archipelago"), String("blkdebug"), String("blkverify"), String("bochs"), String("cloop"), String("dmg"), String("file"), String("ftp"), String("ftps"), String("host_cdrom"), String("host_device"), String("host_floppy"), String("http"), String("https"), String("null-aio"), String("null-co"), String("parallels"), String("qcow"), String("qcow2"), String("qed"), String("quorum"), String("raw"), String("tftp"), String("vdi"), String("vhdx"), String("vmdk"), String("vpc"), String("vvfat")]), "enum": String("BlockdevDriver")}))
kablam! Json result: Ok(Object({"data": Object({"*aio": String("BlockdevAioOptions"), "*cache": String("BlockdevCacheOptions"), "*detect-zeroes": String("BlockdevDetectZeroesOptions"), "*discard": String("BlockdevDiscardOptions"), "*id": String("str"), "*node-name": String("str"), "*read-only": String("bool"), "*rerror": String("BlockdevOnError"), "*werror": String("BlockdevOnError"), "driver": String("BlockdevDriver")}), "struct": String("BlockdevOptionsBase")}))
kablam! Json result: Ok(Object({"data": Object({"filename": String("str")}), "struct": String("BlockdevOptionsFile")}))
kablam! Json result: Ok(Object({"data": Object({"*latency-ns": String("uint64"), "*size": String("int")}), "struct": String("BlockdevOptionsNull")}))
kablam! Json result: Ok(Object({"data": Object({"*fat-type": String("int"), "*floppy": String("bool"), "*rw": String("bool"), "dir": String("str")}), "struct": String("BlockdevOptionsVVFAT")}))
kablam! Json result: Ok(Object({"data": Object({"file": String("BlockdevRef")}), "struct": String("BlockdevOptionsGenericFormat")}))
kablam! Json result: Ok(Object({"base": String("BlockdevOptionsGenericFormat"), "data": Object({"*backing": String("BlockdevRef")}), "struct": String("BlockdevOptionsGenericCOWFormat")}))
kablam! Json result: Ok(Object({"data": Array([String("none"), String("constant"), String("cached"), String("all")]), "enum": String("Qcow2OverlapCheckMode")}))
kablam! Json result: Ok(Object({"data": Object({"*active-l1": String("bool"), "*active-l2": String("bool"), "*inactive-l1": String("bool"), "*inactive-l2": String("bool"), "*main-header": String("bool"), "*refcount-block": String("bool"), "*refcount-table": String("bool"), "*snapshot-table": String("bool"), "*template": String("Qcow2OverlapCheckMode")}), "struct": String("Qcow2OverlapCheckFlags")}))
kablam! Json result: Ok(Object({"alternate": String("Qcow2OverlapChecks"), "data": Object({"flags": String("Qcow2OverlapCheckFlags"), "mode": String("Qcow2OverlapCheckMode")})}))
kablam! Json result: Ok(Object({"base": String("BlockdevOptionsGenericCOWFormat"), "data": Object({"*cache-size": String("int"), "*l2-cache-size": String("int"), "*lazy-refcounts": String("bool"), "*overlap-check": String("Qcow2OverlapChecks"), "*pass-discard-other": String("bool"), "*pass-discard-request": String("bool"), "*pass-discard-snapshot": String("bool"), "*refcount-cache-size": String("int")}), "struct": String("BlockdevOptionsQcow2")}))
kablam! Json result: Ok(Object({"data": Object({"*mport": String("int"), "*segment": String("str"), "*vport": String("int"), "volume": String("str")}), "struct": String("BlockdevOptionsArchipelago")}))
kablam! Json result: Ok(Object({"data": Array([String("l1_update"), String("l1_grow.alloc_table"), String("l1_grow.write_table"), String("l1_grow.activate_table"), String("l2_load"), String("l2_update"), String("l2_update_compressed"), String("l2_alloc.cow_read"), String("l2_alloc.write"), String("read_aio"), String("read_backing_aio"), String("read_compressed"), String("write_aio"), String("write_compressed"), String("vmstate_load"), String("vmstate_save"), String("cow_read"), String("cow_write"), String("reftable_load"), String("reftable_grow"), String("reftable_update"), String("refblock_load"), String("refblock_update"), String("refblock_update_part"), String("refblock_alloc"), String("refblock_alloc.hookup"), String("refblock_alloc.write"), String("refblock_alloc.write_blocks"), String("refblock_alloc.write_table"), String("refblock_alloc.switch_table"), String("cluster_alloc"), String("cluster_alloc_bytes"), String("cluster_free"), String("flush_to_os"), String("flush_to_disk"), String("pwritev_rmw.head"), String("pwritev_rmw.after_head"), String("pwritev_rmw.tail"), String("pwritev_rmw.after_tail"), String("pwritev"), String("pwritev_zero"), String("pwritev_done"), String("empty_image_prepare")]), "enum": String("BlkdebugEvent")}))
kablam! Json result: Ok(Object({"data": Object({"*errno": String("int"), "*immediately": String("bool"), "*once": String("bool"), "*sector": String("int"), "*state": String("int"), "event": String("BlkdebugEvent")}), "struct": String("BlkdebugInjectErrorOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*state": String("int"), "event": String("BlkdebugEvent"), "new_state": String("int")}), "struct": String("BlkdebugSetStateOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*align": String("int"), "*config": String("str"), "*inject-error": Array([String("BlkdebugInjectErrorOptions")]), "*set-state": Array([String("BlkdebugSetStateOptions")]), "image": String("BlockdevRef")}), "struct": String("BlockdevOptionsBlkdebug")}))
kablam! Json result: Ok(Object({"data": Object({"raw": String("BlockdevRef"), "test": String("BlockdevRef")}), "struct": String("BlockdevOptionsBlkverify")}))
kablam! Json result: Ok(Object({"data": Array([String("quorum"), String("fifo")]), "enum": String("QuorumReadPattern")}))
kablam! Json result: Ok(Object({"data": Object({"*blkverify": String("bool"), "*read-pattern": String("QuorumReadPattern"), "*rewrite-corrupted": String("bool"), "children": Array([String("BlockdevRef")]), "vote-threshold": String("int")}), "struct": String("BlockdevOptionsQuorum")}))
kablam! Json result: Ok(Object({"base": String("BlockdevOptionsBase"), "data": Object({"archipelago": String("BlockdevOptionsArchipelago"), "blkdebug": String("BlockdevOptionsBlkdebug"), "blkverify": String("BlockdevOptionsBlkverify"), "bochs": String("BlockdevOptionsGenericFormat"), "cloop": String("BlockdevOptionsGenericFormat"), "dmg": String("BlockdevOptionsGenericFormat"), "file": String("BlockdevOptionsFile"), "ftp": String("BlockdevOptionsFile"), "ftps": String("BlockdevOptionsFile"), "host_cdrom": String("BlockdevOptionsFile"), "host_device": String("BlockdevOptionsFile"), "host_floppy": String("BlockdevOptionsFile"), "http": String("BlockdevOptionsFile"), "https": String("BlockdevOptionsFile"), "null-aio": String("BlockdevOptionsNull"), "null-co": String("BlockdevOptionsNull"), "parallels": String("BlockdevOptionsGenericFormat"), "qcow": String("BlockdevOptionsGenericCOWFormat"), "qcow2": String("BlockdevOptionsQcow2"), "qed": String("BlockdevOptionsGenericCOWFormat"), "quorum": String("BlockdevOptionsQuorum"), "raw": String("BlockdevOptionsGenericFormat"), "tftp": String("BlockdevOptionsFile"), "vdi": String("BlockdevOptionsGenericFormat"), "vhdx": String("BlockdevOptionsGenericFormat"), "vmdk": String("BlockdevOptionsGenericCOWFormat"), "vpc": String("BlockdevOptionsGenericFormat"), "vvfat": String("BlockdevOptionsVVFAT")}), "discriminator": String("driver"), "union": String("BlockdevOptions")}))
kablam! Json result: Ok(Object({"alternate": String("BlockdevRef"), "data": Object({"definition": String("BlockdevOptions"), "reference": String("str")})}))
kablam! Json result: Ok(Object({"command": String("blockdev-add"), "data": Object({"options": String("BlockdevOptions")})}))
kablam! Json result: Ok(Object({"data": Array([String("ignore"), String("report"), String("stop")]), "enum": String("BlockErrorAction")}))
kablam! Json result: Ok(Object({"data": Object({"*node-name": String("str"), "*offset": String("int"), "*size": String("int"), "device": String("str"), "fatal": String("bool"), "msg": String("str")}), "event": String("BLOCK_IMAGE_CORRUPTED")}))
kablam! Json result: Ok(Object({"data": Object({"*nospace": String("bool"), "action": String("BlockErrorAction"), "device": String("str"), "operation": String("IoOperationType"), "reason": String("str")}), "event": String("BLOCK_IO_ERROR")}))
kablam! Json result: Ok(Object({"data": Object({"*error": String("str"), "device": String("str"), "len": String("int"), "offset": String("int"), "speed": String("int"), "type": String("BlockJobType")}), "event": String("BLOCK_JOB_COMPLETED")}))
kablam! Json result: Ok(Object({"data": Object({"device": String("str"), "len": String("int"), "offset": String("int"), "speed": String("int"), "type": String("BlockJobType")}), "event": String("BLOCK_JOB_CANCELLED")}))
kablam! Json result: Ok(Object({"data": Object({"action": String("BlockErrorAction"), "device": String("str"), "operation": String("IoOperationType")}), "event": String("BLOCK_JOB_ERROR")}))
kablam! Json result: Ok(Object({"data": Object({"device": String("str"), "len": String("int"), "offset": String("int"), "speed": String("int"), "type": String("BlockJobType")}), "event": String("BLOCK_JOB_READY")}))
kablam! Json result: Ok(Object({"data": Array([String("off"), String("metadata"), String("falloc"), String("full")]), "enum": String("PreallocMode")}))
kablam! Json result: Ok(Object({"data": Object({"amount-exceeded": String("uint64"), "node-name": String("str"), "write-threshold": String("uint64")}), "event": String("BLOCK_WRITE_THRESHOLD")}))
kablam! Json result: Ok(Object({"command": String("block-set-write-threshold"), "data": Object({"node-name": String("str"), "write-threshold": String("uint64")})}))
kablam! Json result: Ok(Object({"data": Array([String("GenericError"), String("CommandNotFound"), String("DeviceEncrypted"), String("DeviceNotActive"), String("DeviceNotFound"), String("KVMMissingCap")]), "enum": String("ErrorClass")}))
kablam! Json result: Ok(Object({"data": Object({"major": String("int"), "micro": String("int"), "minor": String("int")}), "struct": String("VersionTriple")}))
kablam! Json result: Ok(Object({"data": Object({"package": String("str"), "qemu": String("VersionTriple")}), "struct": String("VersionInfo")}))
kablam! Json result: Ok(Object({"command": String("query-version"), "returns": String("VersionInfo")}))
kablam! Json result: Ok(Object({"data": Object({"name": String("str")}), "struct": String("CommandInfo")}))
kablam! Json result: Ok(Object({"command": String("query-commands"), "returns": Array([String("CommandInfo")])}))
kablam! Json result: Ok(Object({"data": Array([String("auto"), String("on"), String("off")]), "enum": String("OnOffAuto")}))
kablam! Json result: Ok(Object({"data": Array([String("unavailable"), String("disabled"), String("enabled")]), "enum": String("TraceEventState")}))
kablam! Json result: Ok(Object({"data": Object({"name": String("str"), "state": String("TraceEventState")}), "struct": String("TraceEventInfo")}))
kablam! Json result: Ok(Object({"command": String("trace-event-get-state"), "data": Object({"name": String("str")}), "returns": Array([String("TraceEventInfo")])}))
kablam! Json result: Ok(Object({"command": String("trace-event-set-state"), "data": Object({"*ignore-unavailable": String("bool"), "enable": String("bool"), "name": String("str")})}))
kablam! Json result: Ok(Object({"event": String("SHUTDOWN")}))
kablam! Json result: Ok(Object({"event": String("POWERDOWN")}))
kablam! Json result: Ok(Object({"event": String("RESET")}))
kablam! Json result: Ok(Object({"event": String("STOP")}))
kablam! Json result: Ok(Object({"event": String("RESUME")}))
kablam! Json result: Ok(Object({"event": String("SUSPEND")}))
kablam! Json result: Ok(Object({"event": String("SUSPEND_DISK")}))
kablam! Json result: Ok(Object({"event": String("WAKEUP")}))
kablam! Json result: Ok(Object({"data": Object({"offset": String("int")}), "event": String("RTC_CHANGE")}))
kablam! Json result: Ok(Object({"data": Object({"action": String("WatchdogExpirationAction")}), "event": String("WATCHDOG")}))
kablam! Json result: Ok(Object({"data": Object({"*device": String("str"), "path": String("str")}), "event": String("DEVICE_DELETED")}))
kablam! Json result: Ok(Object({"data": Object({"*name": String("str"), "path": String("str")}), "event": String("NIC_RX_FILTER_CHANGED")}))
kablam! Json result: Ok(Object({"data": Object({"client": String("VncBasicInfo"), "server": String("VncServerInfo")}), "event": String("VNC_CONNECTED")}))
kablam! Json result: Ok(Object({"data": Object({"client": String("VncClientInfo"), "server": String("VncServerInfo")}), "event": String("VNC_INITIALIZED")}))
kablam! Json result: Ok(Object({"data": Object({"client": String("VncClientInfo"), "server": String("VncServerInfo")}), "event": String("VNC_DISCONNECTED")}))
kablam! Json result: Ok(Object({"data": Object({"client": String("SpiceBasicInfo"), "server": String("SpiceBasicInfo")}), "event": String("SPICE_CONNECTED")}))
kablam! Json result: Ok(Object({"data": Object({"client": String("SpiceChannel"), "server": String("SpiceServerInfo")}), "event": String("SPICE_INITIALIZED")}))
kablam! Json result: Ok(Object({"data": Object({"client": String("SpiceBasicInfo"), "server": String("SpiceBasicInfo")}), "event": String("SPICE_DISCONNECTED")}))
kablam! Json result: Ok(Object({"event": String("SPICE_MIGRATE_COMPLETED")}))
kablam! Json result: Ok(Object({"data": Object({"info": String("ACPIOSTInfo")}), "event": String("ACPI_DEVICE_OST")}))
kablam! Json result: Ok(Object({"data": Object({"actual": String("int")}), "event": String("BALLOON_CHANGE")}))
kablam! Json result: Ok(Object({"data": Object({"action": String("GuestPanicAction")}), "event": String("GUEST_PANICKED")}))
kablam! Json result: Ok(Object({"data": Object({"reference": String("str"), "sector-num": String("int"), "sectors-count": String("int")}), "event": String("QUORUM_FAILURE")}))
kablam! Json result: Ok(Object({"data": Object({"*error": String("str"), "node-name": String("str"), "sector-num": String("int"), "sectors-count": String("int")}), "event": String("QUORUM_REPORT_BAD")}))
kablam! Json result: Ok(Object({"data": Object({"id": String("str"), "open": String("bool")}), "event": String("VSERPORT_CHANGE")}))
kablam! Json result: Ok(Object({"data": Object({"device": String("str"), "msg": String("str")}), "event": String("MEM_UNPLUG_ERROR")}))
kablam! Json result: Ok(Object({"include": String("qapi/common.json")}))
kablam! Json result: Ok(Object({"include": String("qapi/block.json")}))
kablam! Json result: Ok(Object({"include": String("qapi/event.json")}))
kablam! Json result: Ok(Object({"include": String("qapi/trace.json")}))
kablam! Json result: Ok(Object({"data": Array([String("discard"), String("delay"), String("merge"), String("slew")]), "enum": String("LostTickPolicy")}))
kablam! Json result: Ok(Object({"command": String("add_client"), "data": Object({"*skipauth": String("bool"), "*tls": String("bool"), "fdname": String("str"), "protocol": String("str")})}))
kablam! Json result: Ok(Object({"data": Object({"*name": String("str")}), "struct": String("NameInfo")}))
kablam! Json result: Ok(Object({"command": String("query-name"), "returns": String("NameInfo")}))
kablam! Json result: Ok(Object({"data": Object({"enabled": String("bool"), "present": String("bool")}), "struct": String("KvmInfo")}))
kablam! Json result: Ok(Object({"command": String("query-kvm"), "returns": String("KvmInfo")}))
kablam! Json result: Ok(Object({"data": Array([String("debug"), String("inmigrate"), String("internal-error"), String("io-error"), String("paused"), String("postmigrate"), String("prelaunch"), String("finish-migrate"), String("restore-vm"), String("running"), String("save-vm"), String("shutdown"), String("suspended"), String("watchdog"), String("guest-panicked")]), "enum": String("RunState")}))
kablam! Json result: Ok(Object({"data": Object({"running": String("bool"), "singlestep": String("bool"), "status": String("RunState")}), "struct": String("StatusInfo")}))
kablam! Json result: Ok(Object({"command": String("query-status"), "returns": String("StatusInfo")}))
kablam! Json result: Ok(Object({"data": Object({"UUID": String("str")}), "struct": String("UuidInfo")}))
kablam! Json result: Ok(Object({"command": String("query-uuid"), "returns": String("UuidInfo")}))
kablam! Json result: Ok(Object({"data": Object({"filename": String("str"), "frontend-open": String("bool"), "label": String("str")}), "struct": String("ChardevInfo")}))
kablam! Json result: Ok(Object({"command": String("query-chardev"), "returns": Array([String("ChardevInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"name": String("str")}), "struct": String("ChardevBackendInfo")}))
kablam! Json result: Ok(Object({"command": String("query-chardev-backends"), "returns": Array([String("ChardevBackendInfo")])}))
kablam! Json result: Ok(Object({"data": Array([String("utf8"), String("base64")]), "enum": String("DataFormat")}))
kablam! Json result: Ok(Object({"command": String("ringbuf-write"), "data": Object({"*format": String("DataFormat"), "data": String("str"), "device": String("str")})}))
kablam! Json result: Ok(Object({"command": String("ringbuf-read"), "data": Object({"*format": String("DataFormat"), "device": String("str"), "size": String("int")}), "returns": String("str")}))
kablam! Json result: Ok(Object({"data": Object({"name": String("str")}), "struct": String("EventInfo")}))
kablam! Json result: Ok(Object({"command": String("query-events"), "returns": Array([String("EventInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"dirty-pages-rate": String("int"), "dirty-sync-count": String("int"), "duplicate": String("int"), "mbps": String("number"), "normal": String("int"), "normal-bytes": String("int"), "remaining": String("int"), "skipped": String("int"), "total": String("int"), "transferred": String("int")}), "struct": String("MigrationStats")}))
kablam! Json result: Ok(Object({"data": Object({"bytes": String("int"), "cache-miss": String("int"), "cache-miss-rate": String("number"), "cache-size": String("int"), "overflow": String("int"), "pages": String("int")}), "struct": String("XBZRLECacheStats")}))
kablam! Json result: Ok(Object({"data": Array([String("none"), String("setup"), String("cancelling"), String("cancelled"), String("active"), String("completed"), String("failed")]), "enum": String("MigrationStatus")}))
kablam! Json result: Ok(Object({"data": Object({"*disk": String("MigrationStats"), "*downtime": String("int"), "*expected-downtime": String("int"), "*ram": String("MigrationStats"), "*setup-time": String("int"), "*status": String("MigrationStatus"), "*total-time": String("int"), "*xbzrle-cache": String("XBZRLECacheStats")}), "struct": String("MigrationInfo")}))
kablam! Json result: Ok(Object({"command": String("query-migrate"), "returns": String("MigrationInfo")}))
kablam! Json result: Ok(Object({"data": Array([String("xbzrle"), String("rdma-pin-all"), String("auto-converge"), String("zero-blocks"), String("compress")]), "enum": String("MigrationCapability")}))
kablam! Json result: Ok(Object({"data": Object({"capability": String("MigrationCapability"), "state": String("bool")}), "struct": String("MigrationCapabilityStatus")}))
kablam! Json result: Ok(Object({"command": String("migrate-set-capabilities"), "data": Object({"capabilities": Array([String("MigrationCapabilityStatus")])})}))
kablam! Json result: Ok(Object({"command": String("query-migrate-capabilities"), "returns": Array([String("MigrationCapabilityStatus")])}))
kablam! Json result: Ok(Object({"data": Array([String("compress-level"), String("compress-threads"), String("decompress-threads")]), "enum": String("MigrationParameter")}))
kablam! Json result: Ok(Object({"command": String("migrate-set-parameters"), "data": Object({"*compress-level": String("int"), "*compress-threads": String("int"), "*decompress-threads": String("int")})}))
kablam! Json result: Ok(Object({"data": Object({"compress-level": String("int"), "compress-threads": String("int"), "decompress-threads": String("int")}), "struct": String("MigrationParameters")}))
kablam! Json result: Ok(Object({"command": String("query-migrate-parameters"), "returns": String("MigrationParameters")}))
kablam! Json result: Ok(Object({"data": Object({"absolute": String("bool"), "current": String("bool"), "index": String("int"), "name": String("str")}), "struct": String("MouseInfo")}))
kablam! Json result: Ok(Object({"command": String("query-mice"), "returns": Array([String("MouseInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"*PC": String("int"), "*nip": String("int"), "*npc": String("int"), "*pc": String("int"), "CPU": String("int"), "current": String("bool"), "halted": String("bool"), "qom_path": String("str"), "thread_id": String("int")}), "struct": String("CpuInfo")}))
kablam! Json result: Ok(Object({"command": String("query-cpus"), "returns": Array([String("CpuInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"id": String("str"), "thread-id": String("int")}), "struct": String("IOThreadInfo")}))
kablam! Json result: Ok(Object({"command": String("query-iothreads"), "returns": Array([String("IOThreadInfo")])}))
kablam! Json result: Ok(Object({"data": Array([String("ipv4"), String("ipv6"), String("unix"), String("unknown")]), "enum": String("NetworkAddressFamily")}))
kablam! Json result: Ok(Object({"data": Object({"family": String("NetworkAddressFamily"), "host": String("str"), "service": String("str"), "websocket": String("bool")}), "struct": String("VncBasicInfo")}))
kablam! Json result: Ok(Object({"base": String("VncBasicInfo"), "data": Object({"*auth": String("str")}), "struct": String("VncServerInfo")}))
kablam! Json result: Ok(Object({"base": String("VncBasicInfo"), "data": Object({"*sasl_username": String("str"), "*x509_dname": String("str")}), "struct": String("VncClientInfo")}))
kablam! Json result: Ok(Object({"data": Object({"*auth": String("str"), "*clients": Array([String("VncClientInfo")]), "*family": String("NetworkAddressFamily"), "*host": String("str"), "*service": String("str"), "enabled": String("bool")}), "struct": String("VncInfo")}))
kablam! Json result: Ok(Object({"data": Array([String("none"), String("vnc"), String("ra2"), String("ra2ne"), String("tight"), String("ultra"), String("tls"), String("vencrypt"), String("sasl")]), "enum": String("VncPrimaryAuth")}))
kablam! Json result: Ok(Object({"data": Array([String("plain"), String("tls-none"), String("x509-none"), String("tls-vnc"), String("x509-vnc"), String("tls-plain"), String("x509-plain"), String("tls-sasl"), String("x509-sasl")]), "enum": String("VncVencryptSubAuth")}))
kablam! Json result: Ok(Object({"data": Object({"*display": String("str"), "*vencrypt": String("VncVencryptSubAuth"), "auth": String("VncPrimaryAuth"), "clients": Array([String("VncClientInfo")]), "id": String("str"), "server": Array([String("VncBasicInfo")])}), "struct": String("VncInfo2")}))
kablam! Json result: Ok(Object({"command": String("query-vnc"), "returns": String("VncInfo")}))
kablam! Json result: Ok(Object({"command": String("query-vnc-servers"), "returns": Array([String("VncInfo2")])}))
kablam! Json result: Ok(Object({"data": Object({"family": String("NetworkAddressFamily"), "host": String("str"), "port": String("str")}), "struct": String("SpiceBasicInfo")}))
kablam! Json result: Ok(Object({"base": String("SpiceBasicInfo"), "data": Object({"*auth": String("str")}), "struct": String("SpiceServerInfo")}))
kablam! Json result: Ok(Object({"base": String("SpiceBasicInfo"), "data": Object({"channel-id": String("int"), "channel-type": String("int"), "connection-id": String("int"), "tls": String("bool")}), "struct": String("SpiceChannel")}))
kablam! Json result: Ok(Object({"data": Array([String("client"), String("server"), String("unknown")]), "enum": String("SpiceQueryMouseMode")}))
kablam! Json result: Ok(Object({"data": Object({"*auth": String("str"), "*channels": Array([String("SpiceChannel")]), "*compiled-version": String("str"), "*host": String("str"), "*port": String("int"), "*tls-port": String("int"), "enabled": String("bool"), "migrated": String("bool"), "mouse-mode": String("SpiceQueryMouseMode")}), "struct": String("SpiceInfo")}))
kablam! Json result: Ok(Object({"command": String("query-spice"), "returns": String("SpiceInfo")}))
kablam! Json result: Ok(Object({"data": Object({"actual": String("int")}), "struct": String("BalloonInfo")}))
kablam! Json result: Ok(Object({"command": String("query-balloon"), "returns": String("BalloonInfo")}))
kablam! Json result: Ok(Object({"data": Object({"base": String("int"), "limit": String("int")}), "struct": String("PciMemoryRange")}))
kablam! Json result: Ok(Object({"data": Object({"*mem_type_64": String("bool"), "*prefetch": String("bool"), "address": String("int"), "bar": String("int"), "size": String("int"), "type": String("str")}), "struct": String("PciMemoryRegion")}))
kablam! Json result: Ok(Object({"data": Object({"io_range": String("PciMemoryRange"), "memory_range": String("PciMemoryRange"), "number": String("int"), "prefetchable_range": String("PciMemoryRange"), "secondary": String("int"), "subordinate": String("int")}), "struct": String("PciBusInfo")}))
kablam! Json result: Ok(Object({"data": Object({"*devices": Array([String("PciDeviceInfo")]), "bus": String("PciBusInfo")}), "struct": String("PciBridgeInfo")}))
kablam! Json result: Ok(Object({"data": Object({"*desc": String("str"), "class": String("int")}), "struct": String("PciDeviceClass")}))
kablam! Json result: Ok(Object({"data": Object({"device": String("int"), "vendor": String("int")}), "struct": String("PciDeviceId")}))
kablam! Json result: Ok(Object({"data": Object({"*irq": String("int"), "*pci_bridge": String("PciBridgeInfo"), "bus": String("int"), "class_info": String("PciDeviceClass"), "function": String("int"), "id": String("PciDeviceId"), "qdev_id": String("str"), "regions": Array([String("PciMemoryRegion")]), "slot": String("int")}), "struct": String("PciDeviceInfo")}))
kablam! Json result: Ok(Object({"data": Object({"bus": String("int"), "devices": Array([String("PciDeviceInfo")])}), "struct": String("PciInfo")}))
kablam! Json result: Ok(Object({"command": String("query-pci"), "returns": Array([String("PciInfo")])}))
kablam! Json result: Ok(Object({"command": String("quit")}))
kablam! Json result: Ok(Object({"command": String("stop")}))
kablam! Json result: Ok(Object({"command": String("system_reset")}))
kablam! Json result: Ok(Object({"command": String("system_powerdown")}))
kablam! Json result: Ok(Object({"command": String("cpu"), "data": Object({"index": String("int")})}))
kablam! Json result: Ok(Object({"command": String("cpu-add"), "data": Object({"id": String("int")})}))
kablam! Json result: Ok(Object({"command": String("memsave"), "data": Object({"*cpu-index": String("int"), "filename": String("str"), "size": String("int"), "val": String("int")})}))
kablam! Json result: Ok(Object({"command": String("pmemsave"), "data": Object({"filename": String("str"), "size": String("int"), "val": String("int")})}))
kablam! Json result: Ok(Object({"command": String("cont")}))
kablam! Json result: Ok(Object({"command": String("system_wakeup")}))
kablam! Json result: Ok(Object({"command": String("inject-nmi")}))
kablam! Json result: Ok(Object({"command": String("set_link"), "data": Object({"name": String("str"), "up": String("bool")})}))
kablam! Json result: Ok(Object({"command": String("balloon"), "data": Object({"value": String("int")})}))
kablam! Json result: Ok(Object({"data": Object({}), "struct": String("Abort")}))
kablam! Json result: Ok(Object({"data": Object({"abort": String("Abort"), "blockdev-backup": String("BlockdevBackup"), "blockdev-snapshot-internal-sync": String("BlockdevSnapshotInternal"), "blockdev-snapshot-sync": String("BlockdevSnapshot"), "drive-backup": String("DriveBackup")}), "union": String("TransactionAction")}))
kablam! Json result: Ok(Object({"command": String("transaction"), "data": Object({"actions": Array([String("TransactionAction")])})}))
kablam! Json result: Ok(Object({"command": String("human-monitor-command"), "data": Object({"*cpu-index": String("int"), "command-line": String("str")}), "returns": String("str")}))
kablam! Json result: Ok(Object({"command": String("migrate_cancel")}))
kablam! Json result: Ok(Object({"command": String("migrate_set_downtime"), "data": Object({"value": String("number")})}))
kablam! Json result: Ok(Object({"command": String("migrate_set_speed"), "data": Object({"value": String("int")})}))
kablam! Json result: Ok(Object({"command": String("migrate-set-cache-size"), "data": Object({"value": String("int")})}))
kablam! Json result: Ok(Object({"command": String("query-migrate-cache-size"), "returns": String("int")}))
kablam! Json result: Ok(Object({"data": Object({"name": String("str"), "type": String("str")}), "struct": String("ObjectPropertyInfo")}))
kablam! Json result: Ok(Object({"command": String("qom-list"), "data": Object({"path": String("str")}), "returns": Array([String("ObjectPropertyInfo")])}))
kablam! Json result: Ok(Object({"command": String("qom-get"), "data": Object({"path": String("str"), "property": String("str")}), "gen": Boolean(false), "returns": String("**")}))
kablam! Json result: Ok(Object({"command": String("qom-set"), "data": Object({"path": String("str"), "property": String("str"), "value": String("**")}), "gen": Boolean(false)}))
kablam! Json result: Ok(Object({"command": String("set_password"), "data": Object({"*connected": String("str"), "password": String("str"), "protocol": String("str")})}))
kablam! Json result: Ok(Object({"command": String("expire_password"), "data": Object({"protocol": String("str"), "time": String("str")})}))
kablam! Json result: Ok(Object({"command": String("change-vnc-password"), "data": Object({"password": String("str")})}))
kablam! Json result: Ok(Object({"command": String("change"), "data": Object({"*arg": String("str"), "device": String("str"), "target": String("str")})}))
kablam! Json result: Ok(Object({"data": Object({"name": String("str")}), "struct": String("ObjectTypeInfo")}))
kablam! Json result: Ok(Object({"command": String("qom-list-types"), "data": Object({"*abstract": String("bool"), "*implements": String("str")}), "returns": Array([String("ObjectTypeInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"*description": String("str"), "name": String("str"), "type": String("str")}), "struct": String("DevicePropertyInfo")}))
kablam! Json result: Ok(Object({"command": String("device-list-properties"), "data": Object({"typename": String("str")}), "returns": Array([String("DevicePropertyInfo")])}))
kablam! Json result: Ok(Object({"command": String("migrate"), "data": Object({"*blk": String("bool"), "*detach": String("bool"), "*inc": String("bool"), "uri": String("str")})}))
kablam! Json result: Ok(Object({"command": String("migrate-incoming"), "data": Object({"uri": String("str")})}))
kablam! Json result: Ok(Object({"command": String("xen-save-devices-state"), "data": Object({"filename": String("str")})}))
kablam! Json result: Ok(Object({"command": String("xen-set-global-dirty-log"), "data": Object({"enable": String("bool")})}))
kablam! Json result: Ok(Object({"command": String("device_del"), "data": Object({"id": String("str")})}))
kablam! Json result: Ok(Object({"data": Array([String("elf"), String("kdump-zlib"), String("kdump-lzo"), String("kdump-snappy")]), "enum": String("DumpGuestMemoryFormat")}))
kablam! Json result: Ok(Object({"command": String("dump-guest-memory"), "data": Object({"*begin": String("int"), "*format": String("DumpGuestMemoryFormat"), "*length": String("int"), "paging": String("bool"), "protocol": String("str")})}))
kablam! Json result: Ok(Object({"data": Object({"formats": Array([String("DumpGuestMemoryFormat")])}), "struct": String("DumpGuestMemoryCapability")}))
kablam! Json result: Ok(Object({"command": String("query-dump-guest-memory-capability"), "returns": String("DumpGuestMemoryCapability")}))
kablam! Json result: Ok(Object({"command": String("netdev_add"), "data": Object({"*props": String("**"), "id": String("str"), "type": String("str")}), "gen": Boolean(false)}))
kablam! Json result: Ok(Object({"command": String("netdev_del"), "data": Object({"id": String("str")})}))
kablam! Json result: Ok(Object({"command": String("object-add"), "data": Object({"*props": String("**"), "id": String("str"), "qom-type": String("str")}), "gen": Boolean(false)}))
kablam! Json result: Ok(Object({"command": String("object-del"), "data": Object({"id": String("str")})}))
kablam! Json result: Ok(Object({"data": Object({}), "struct": String("NetdevNoneOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*addr": String("str"), "*macaddr": String("str"), "*model": String("str"), "*netdev": String("str"), "*vectors": String("uint32")}), "struct": String("NetLegacyNicOptions")}))
kablam! Json result: Ok(Object({"data": Object({"str": String("str")}), "struct": String("String")}))
kablam! Json result: Ok(Object({"data": Object({"*bootfile": String("str"), "*dhcpstart": String("str"), "*dns": String("str"), "*dnssearch": Array([String("String")]), "*guestfwd": Array([String("String")]), "*host": String("str"), "*hostfwd": Array([String("String")]), "*hostname": String("str"), "*ip": String("str"), "*net": String("str"), "*restrict": String("bool"), "*smb": String("str"), "*smbserver": String("str"), "*tftp": String("str")}), "struct": String("NetdevUserOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*downscript": String("str"), "*fd": String("str"), "*fds": String("str"), "*helper": String("str"), "*ifname": String("str"), "*queues": String("uint32"), "*script": String("str"), "*sndbuf": String("size"), "*vhost": String("bool"), "*vhostfd": String("str"), "*vhostfds": String("str"), "*vhostforce": String("bool"), "*vnet_hdr": String("bool")}), "struct": String("NetdevTapOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*connect": String("str"), "*fd": String("str"), "*listen": String("str"), "*localaddr": String("str"), "*mcast": String("str"), "*udp": String("str")}), "struct": String("NetdevSocketOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*cookie64": String("bool"), "*counter": String("bool"), "*dstport": String("str"), "*ipv6": String("bool"), "*offset": String("uint32"), "*pincounter": String("bool"), "*rxcookie": String("uint64"), "*rxsession": String("uint32"), "*srcport": String("str"), "*txcookie": String("uint64"), "*udp": String("bool"), "dst": String("str"), "src": String("str"), "txsession": String("uint32")}), "struct": String("NetdevL2TPv3Options")}))
kablam! Json result: Ok(Object({"data": Object({"*group": String("str"), "*mode": String("uint16"), "*port": String("uint16"), "*sock": String("str")}), "struct": String("NetdevVdeOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*file": String("str"), "*len": String("size")}), "struct": String("NetdevDumpOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*br": String("str"), "*helper": String("str")}), "struct": String("NetdevBridgeOptions")}))
kablam! Json result: Ok(Object({"data": Object({"hubid": String("int32")}), "struct": String("NetdevHubPortOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*devname": String("str"), "ifname": String("str")}), "struct": String("NetdevNetmapOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*vhostforce": String("bool"), "chardev": String("str")}), "struct": String("NetdevVhostUserOptions")}))
kablam! Json result: Ok(Object({"data": Object({"bridge": String("NetdevBridgeOptions"), "dump": String("NetdevDumpOptions"), "hubport": String("NetdevHubPortOptions"), "l2tpv3": String("NetdevL2TPv3Options"), "netmap": String("NetdevNetmapOptions"), "nic": String("NetLegacyNicOptions"), "none": String("NetdevNoneOptions"), "socket": String("NetdevSocketOptions"), "tap": String("NetdevTapOptions"), "user": String("NetdevUserOptions"), "vde": String("NetdevVdeOptions"), "vhost-user": String("NetdevVhostUserOptions")}), "union": String("NetClientOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*id": String("str"), "*name": String("str"), "*vlan": String("int32"), "opts": String("NetClientOptions")}), "struct": String("NetLegacy")}))
kablam! Json result: Ok(Object({"data": Object({"id": String("str"), "opts": String("NetClientOptions")}), "struct": String("Netdev")}))
kablam! Json result: Ok(Object({"data": Object({"*ipv4": String("bool"), "*ipv6": String("bool"), "*to": String("uint16"), "host": String("str"), "port": String("str")}), "struct": String("InetSocketAddress")}))
kablam! Json result: Ok(Object({"data": Object({"path": String("str")}), "struct": String("UnixSocketAddress")}))
kablam! Json result: Ok(Object({"data": Object({"fd": String("String"), "inet": String("InetSocketAddress"), "unix": String("UnixSocketAddress")}), "union": String("SocketAddress")}))
kablam! Json result: Ok(Object({"command": String("getfd"), "data": Object({"fdname": String("str")})}))
kablam! Json result: Ok(Object({"command": String("closefd"), "data": Object({"fdname": String("str")})}))
kablam! Json result: Ok(Object({"data": Object({"*alias": String("str"), "*is-default": String("bool"), "cpu-max": String("int"), "name": String("str")}), "struct": String("MachineInfo")}))
kablam! Json result: Ok(Object({"command": String("query-machines"), "returns": Array([String("MachineInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"name": String("str")}), "struct": String("CpuDefinitionInfo")}))
kablam! Json result: Ok(Object({"command": String("query-cpu-definitions"), "returns": Array([String("CpuDefinitionInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"fd": String("int"), "fdset-id": String("int")}), "struct": String("AddfdInfo")}))
kablam! Json result: Ok(Object({"command": String("add-fd"), "data": Object({"*fdset-id": String("int"), "*opaque": String("str")}), "returns": String("AddfdInfo")}))
kablam! Json result: Ok(Object({"command": String("remove-fd"), "data": Object({"*fd": String("int"), "fdset-id": String("int")})}))
kablam! Json result: Ok(Object({"data": Object({"*opaque": String("str"), "fd": String("int")}), "struct": String("FdsetFdInfo")}))
kablam! Json result: Ok(Object({"data": Object({"fds": Array([String("FdsetFdInfo")]), "fdset-id": String("int")}), "struct": String("FdsetInfo")}))
kablam! Json result: Ok(Object({"command": String("query-fdsets"), "returns": Array([String("FdsetInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"arch": String("str")}), "struct": String("TargetInfo")}))
kablam! Json result: Ok(Object({"command": String("query-target"), "returns": String("TargetInfo")}))
kablam! Json result: Ok(Object({"data": Array([String("unmapped"), String("shift"), String("shift_r"), String("alt"), String("alt_r"), String("altgr"), String("altgr_r"), String("ctrl"), String("ctrl_r"), String("menu"), String("esc"), String("1"), String("2"), String("3"), String("4"), String("5"), String("6"), String("7"), String("8"), String("9"), String("0"), String("minus"), String("equal"), String("backspace"), String("tab"), String("q"), String("w"), String("e"), String("r"), String("t"), String("y"), String("u"), String("i"), String("o"), String("p"), String("bracket_left"), String("bracket_right"), String("ret"), String("a"), String("s"), String("d"), String("f"), String("g"), String("h"), String("j"), String("k"), String("l"), String("semicolon"), String("apostrophe"), String("grave_accent"), String("backslash"), String("z"), String("x"), String("c"), String("v"), String("b"), String("n"), String("m"), String("comma"), String("dot"), String("slash"), String("asterisk"), String("spc"), String("caps_lock"), String("f1"), String("f2"), String("f3"), String("f4"), String("f5"), String("f6"), String("f7"), String("f8"), String("f9"), String("f10"), String("num_lock"), String("scroll_lock"), String("kp_divide"), String("kp_multiply"), String("kp_subtract"), String("kp_add"), String("kp_enter"), String("kp_decimal"), String("sysrq"), String("kp_0"), String("kp_1"), String("kp_2"), String("kp_3"), String("kp_4"), String("kp_5"), String("kp_6"), String("kp_7"), String("kp_8"), String("kp_9"), String("less"), String("f11"), String("f12"), String("print"), String("home"), String("pgup"), String("pgdn"), String("end"), String("left"), String("up"), String("down"), String("right"), String("insert"), String("delete"), String("stop"), String("again"), String("props"), String("undo"), String("front"), String("copy"), String("open"), String("paste"), String("find"), String("cut"), String("lf"), String("help"), String("meta_l"), String("meta_r"), String("compose"), String("pause")]), "enum": String("QKeyCode")}))
kablam! Json result: Ok(Object({"data": Object({"number": String("int"), "qcode": String("QKeyCode")}), "union": String("KeyValue")}))
kablam! Json result: Ok(Object({"command": String("send-key"), "data": Object({"*hold-time": String("int"), "keys": Array([String("KeyValue")])})}))
kablam! Json result: Ok(Object({"command": String("screendump"), "data": Object({"filename": String("str")})}))
kablam! Json result: Ok(Object({"data": Object({"*in": String("str"), "out": String("str")}), "struct": String("ChardevFile")}))
kablam! Json result: Ok(Object({"data": Object({"device": String("str")}), "struct": String("ChardevHostdev")}))
kablam! Json result: Ok(Object({"data": Object({"*nodelay": String("bool"), "*reconnect": String("int"), "*server": String("bool"), "*telnet": String("bool"), "*wait": String("bool"), "addr": String("SocketAddress")}), "struct": String("ChardevSocket")}))
kablam! Json result: Ok(Object({"data": Object({"*local": String("SocketAddress"), "remote": String("SocketAddress")}), "struct": String("ChardevUdp")}))
kablam! Json result: Ok(Object({"data": Object({"chardev": String("str")}), "struct": String("ChardevMux")}))
kablam! Json result: Ok(Object({"data": Object({"*signal": String("bool")}), "struct": String("ChardevStdio")}))
kablam! Json result: Ok(Object({"data": Object({"type": String("str")}), "struct": String("ChardevSpiceChannel")}))
kablam! Json result: Ok(Object({"data": Object({"fqdn": String("str")}), "struct": String("ChardevSpicePort")}))
kablam! Json result: Ok(Object({"data": Object({"*cols": String("int"), "*height": String("int"), "*rows": String("int"), "*width": String("int")}), "struct": String("ChardevVC")}))
kablam! Json result: Ok(Object({"data": Object({"*size": String("int")}), "struct": String("ChardevRingbuf")}))
kablam! Json result: Ok(Object({"data": Object({}), "struct": String("ChardevDummy")}))
kablam! Json result: Ok(Object({"data": Object({"braille": String("ChardevDummy"), "console": String("ChardevDummy"), "file": String("ChardevFile"), "memory": String("ChardevRingbuf"), "msmouse": String("ChardevDummy"), "mux": String("ChardevMux"), "null": String("ChardevDummy"), "parallel": String("ChardevHostdev"), "pipe": String("ChardevHostdev"), "pty": String("ChardevDummy"), "ringbuf": String("ChardevRingbuf"), "serial": String("ChardevHostdev"), "socket": String("ChardevSocket"), "spiceport": String("ChardevSpicePort"), "spicevmc": String("ChardevSpiceChannel"), "stdio": String("ChardevStdio"), "testdev": String("ChardevDummy"), "udp": String("ChardevUdp"), "vc": String("ChardevVC")}), "union": String("ChardevBackend")}))
kablam! Json result: Ok(Object({"data": Object({"*pty": String("str")}), "struct": String("ChardevReturn")}))
kablam! Json result: Ok(Object({"command": String("chardev-add"), "data": Object({"backend": String("ChardevBackend"), "id": String("str")}), "returns": String("ChardevReturn")}))
kablam! Json result: Ok(Object({"command": String("chardev-remove"), "data": Object({"id": String("str")})}))
kablam! Json result: Ok(Object({"data": Array([String("tpm-tis")]), "enum": String("TpmModel")}))
kablam! Json result: Ok(Object({"command": String("query-tpm-models"), "returns": Array([String("TpmModel")])}))
kablam! Json result: Ok(Object({"data": Array([String("passthrough")]), "enum": String("TpmType")}))
kablam! Json result: Ok(Object({"command": String("query-tpm-types"), "returns": Array([String("TpmType")])}))
kablam! Json result: Ok(Object({"data": Object({"*cancel-path": String("str"), "*path": String("str")}), "struct": String("TPMPassthroughOptions")}))
kablam! Json result: Ok(Object({"data": Object({"passthrough": String("TPMPassthroughOptions")}), "union": String("TpmTypeOptions")}))
kablam! Json result: Ok(Object({"data": Object({"id": String("str"), "model": String("TpmModel"), "options": String("TpmTypeOptions")}), "struct": String("TPMInfo")}))
kablam! Json result: Ok(Object({"command": String("query-tpm"), "returns": Array([String("TPMInfo")])}))
kablam! Json result: Ok(Object({"data": Object({"*asl_compiler_id": String("str"), "*asl_compiler_rev": String("uint32"), "*data": String("str"), "*file": String("str"), "*oem_id": String("str"), "*oem_rev": String("uint32"), "*oem_table_id": String("str"), "*rev": String("uint8"), "*sig": String("str")}), "struct": String("AcpiTableOptions")}))
kablam! Json result: Ok(Object({"data": Array([String("string"), String("boolean"), String("number"), String("size")]), "enum": String("CommandLineParameterType")}))
kablam! Json result: Ok(Object({"data": Object({"*default": String("str"), "*help": String("str"), "name": String("str"), "type": String("CommandLineParameterType")}), "struct": String("CommandLineParameterInfo")}))
kablam! Json result: Ok(Object({"data": Object({"option": String("str"), "parameters": Array([String("CommandLineParameterInfo")])}), "struct": String("CommandLineOptionInfo")}))
kablam! Json result: Ok(Object({"command": String("query-command-line-options"), "data": Object({"*option": String("str")}), "returns": Array([String("CommandLineOptionInfo")])}))
kablam! Json result: Ok(Object({"data": Array([String("EAX"), String("EBX"), String("ECX"), String("EDX"), String("ESP"), String("EBP"), String("ESI"), String("EDI")]), "enum": String("X86CPURegister32")}))
kablam! Json result: Ok(Object({"data": Object({"*cpuid-input-ecx": String("int"), "cpuid-input-eax": String("int"), "cpuid-register": String("X86CPURegister32"), "features": String("int")}), "struct": String("X86CPUFeatureWordInfo")}))
kablam! Json result: Ok(Object({"data": Array([String("normal"), String("none"), String("all")]), "enum": String("RxState")}))
kablam! Json result: Ok(Object({"data": Object({"broadcast-allowed": String("bool"), "main-mac": String("str"), "multicast": String("RxState"), "multicast-overflow": String("bool"), "multicast-table": Array([String("str")]), "name": String("str"), "promiscuous": String("bool"), "unicast": String("RxState"), "unicast-overflow": String("bool"), "unicast-table": Array([String("str")]), "vlan": String("RxState"), "vlan-table": Array([String("int")])}), "struct": String("RxFilterInfo")}))
kablam! Json result: Ok(Object({"command": String("query-rx-filter"), "data": Object({"*name": String("str")}), "returns": Array([String("RxFilterInfo")])}))
kablam! Json result: Ok(Object({"data": Array([String("Left"), String("Middle"), String("Right"), String("WheelUp"), String("WheelDown")]), "enum": String("InputButton")}))
kablam! Json result: Ok(Object({"data": Array([String("X"), String("Y")]), "enum": String("InputAxis")}))
kablam! Json result: Ok(Object({"data": Object({"down": String("bool"), "key": String("KeyValue")}), "struct": String("InputKeyEvent")}))
kablam! Json result: Ok(Object({"data": Object({"button": String("InputButton"), "down": String("bool")}), "struct": String("InputBtnEvent")}))
kablam! Json result: Ok(Object({"data": Object({"axis": String("InputAxis"), "value": String("int")}), "struct": String("InputMoveEvent")}))
kablam! Json result: Ok(Object({"data": Object({"abs": String("InputMoveEvent"), "btn": String("InputBtnEvent"), "key": String("InputKeyEvent"), "rel": String("InputMoveEvent")}), "union": String("InputEvent")}))
kablam! Json result: Ok(Object({"command": String("x-input-send-event"), "data": Object({"*console": String("int"), "events": Array([String("InputEvent")])})}))
kablam! Json result: Ok(Object({"data": Object({"node": String("NumaNodeOptions")}), "union": String("NumaOptions")}))
kablam! Json result: Ok(Object({"data": Object({"*cpus": Array([String("uint16")]), "*mem": String("size"), "*memdev": String("str"), "*nodeid": String("uint16")}), "struct": String("NumaNodeOptions")}))
kablam! Json result: Ok(Object({"data": Array([String("default"), String("preferred"), String("bind"), String("interleave")]), "enum": String("HostMemPolicy")}))
kablam! Json result: Ok(Object({"data": Object({"dump": String("bool"), "host-nodes": Array([String("uint16")]), "merge": String("bool"), "policy": String("HostMemPolicy"), "prealloc": String("bool"), "size": String("size")}), "struct": String("Memdev")}))
kablam! Json result: Ok(Object({"command": String("query-memdev"), "returns": Array([String("Memdev")])}))
kablam! Json result: Ok(Object({"data": Object({"*id": String("str"), "addr": String("int"), "hotpluggable": String("bool"), "hotplugged": String("bool"), "memdev": String("str"), "node": String("int"), "size": String("int"), "slot": String("int")}), "struct": String("PCDIMMDeviceInfo")}))
kablam! Json result: Ok(Object({"data": Object({"dimm": String("PCDIMMDeviceInfo")}), "union": String("MemoryDeviceInfo")}))
kablam! Json result: Ok(Object({"command": String("query-memory-devices"), "returns": Array([String("MemoryDeviceInfo")])}))
kablam! Json result: Ok(Object({"data": Array([String("DIMM")]), "enum": String("ACPISlotType")}))
kablam! Json result: Ok(Object({"data": Object({"*device": String("str"), "slot": String("str"), "slot-type": String("ACPISlotType"), "source": String("int"), "status": String("int")}), "struct": String("ACPIOSTInfo")}))
kablam! Json result: Ok(Object({"command": String("query-acpi-ospm-status"), "returns": Array([String("ACPIOSTInfo")])}))
kablam! Json result: Ok(Object({"data": Array([String("reset"), String("shutdown"), String("poweroff"), String("pause"), String("debug"), String("none")]), "enum": String("WatchdogExpirationAction")}))
kablam! Json result: Ok(Object({"data": Array([String("read"), String("write")]), "enum": String("IoOperationType")}))
kablam! Json result: Ok(Object({"data": Array([String("pause")]), "enum": String("GuestPanicAction")}))
kablam! Json result: Ok(Object({"command": String("rtc-reset-reinjection")}))
kablam! 2017-03-27 02:55:05 DEBUG [build_script_build] leftover: ""
kablam! 2017-03-27 02:55:05 DEBUG [build_script_build] Result: [Section { description: [], qemu_type: Include { name: "" } }, Section { description: ["#", " BiosAtaTranslation:", "", " Policy that BIOS should use to interpret cylinder/head/sector", " addresses.  Note that Bochs BIOS and SeaBIOS will not actually", " translate logical CHS to physical; instead, they will use logical", " block addressing.", "", " @auto: If cylinder/heads/sizes are passed, choose between none and LBA", "        depending on the size of the disk.  If they are not passed,", "        choose none if QEMU can guess that the disk had 16 or fewer", "        heads, large if QEMU can guess that the disk had 131072 or", "        fewer tracks across all heads (i.e. cylinders*heads<131072),", "        otherwise LBA.", "", " @none: The physical disk geometry is equal to the logical geometry.", "", " @lba: Assume 63 sectors per track and one of 16, 32, 64, 128 or 255", "       heads (if fewer than 255 are enough to cover the whole disk", "       with 1024 cylinders/head).  The number of cylinders/head is", "       then computed based on the number of sectors and heads.", "", " @large: The number of cylinders per head is scaled down to 1024", "         by correspondingly scaling up the number of heads.", "", " @rechs: Same as @large, but first convert a 16-head geometry to", "         15-head, by proportionally scaling up the number of", "         cylinders/head.", "", " Since: 2.0", "#"], qemu_type: Enum(Enum { name: "BiosAtaTranslation", fields: Array([String("auto"), String("none"), String("lba"), String("large"), String("rechs")]) }) }, Section { description: ["#", " @BlockdevSnapshotInternal", "", " @device: the name of the device to generate the snapshot from", "", " @name: the name of the internal snapshot to be created", "", " Notes: In transaction, if @name is empty, or any snapshot matching @name", "        exists, the operation will fail. Only some image formats support it,", "        for example, qcow2, rbd, and sheepdog.", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "BlockdevSnapshotInternal", fields: Object({"device": String("str"), "name": String("str")}), base: Null }) }, Section { description: ["#", " @blockdev-snapshot-internal-sync", "", " Synchronously take an internal snapshot of a block device, when the format", " of the image used supports it.", "", " For the arguments, see the documentation of BlockdevSnapshotInternal.", "", " Returns: nothing on success", "          If @device is not a valid block device, DeviceNotFound", "          If any snapshot matching @name exists, or @name is empty,", "          GenericError", "          If the format of the image used does not support it,", "          BlockFormatFeatureNotSupported", "", " Since 1.7", "#"], qemu_type: Command(Command { name: "blockdev-snapshot-internal-sync", fields: String("BlockdevSnapshotInternal"), gen: Null, returns: Null }) }, Section { description: ["#", " @blockdev-snapshot-delete-internal-sync", "", " Synchronously delete an internal snapshot of a block device, when the format", " of the image used support it. The snapshot is identified by name or id or", " both. One of the name or id is required. Return SnapshotInfo for the", " successfully deleted snapshot.", "", " @device: the name of the device to delete the snapshot from", "", " @id: optional the snapshot\"s ID to be deleted", "", " @name: optional the snapshot\"s name to be deleted", "", " Returns: SnapshotInfo on success", "          If @device is not a valid block device, DeviceNotFound", "          If snapshot not found, GenericError", "          If the format of the image used does not support it,", "          BlockFormatFeatureNotSupported", "          If @id and @name are both not specified, GenericError", "", " Since 1.7", "#"], qemu_type: Command(Command { name: "blockdev-snapshot-delete-internal-sync", fields: Object({"*id": String("str"), "*name": String("str"), "device": String("str")}), gen: Null, returns: String("SnapshotInfo") }) }, Section { description: ["#", " @eject:", "", " Ejects a device from a removable drive.", "", " @device:  The name of the device", "", " @force:   @optional If true, eject regardless of whether the drive is locked.", "           If not specified, the default value is false.", "", " Returns:  Nothing on success", "           If @device is not a valid block device, DeviceNotFound", "", " Notes:    Ejecting a device will no media results in success", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "eject", fields: Object({"*force": String("bool"), "device": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @nbd-server-start:", "", " Start an NBD server listening on the given host and port.  Block", " devices can then be exported using @nbd-server-add.  The NBD", " server will present them as named exports; for example, another", " QEMU instance could refer to them as \"nbd:HOST:PORT:exportname=NAME\".", "", " @addr: Address on which to listen.", "", " Returns: error if the server is already running.", "", " Since: 1.3.0", "#"], qemu_type: Command(Command { name: "nbd-server-start", fields: Object({"addr": String("SocketAddress")}), gen: Null, returns: Null }) }, Section { description: ["#", " @nbd-server-add:", "", " Export a device to QEMU\"s embedded NBD server.", "", " @device: Block device to be exported", "", " @writable: Whether clients should be able to write to the device via the", "     NBD connection (default false). #optional", "", " Returns: error if the device is already marked for export.", "", " Since: 1.3.0", "#"], qemu_type: Command(Command { name: "nbd-server-add", fields: Object({"*writable": String("bool"), "device": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @nbd-server-stop:", "", " Stop QEMU\"s embedded NBD server, and unregister all devices previously", " added via @nbd-server-add.", "", " Since: 1.3.0", "#"], qemu_type: Command(Command { name: "nbd-server-stop", fields: Null, gen: Null, returns: Null }) }, Section { description: ["#", " @DEVICE_TRAY_MOVED", "", " Emitted whenever the tray of a removable device is moved by the guest or by", " HMP/QMP commands", "", " @device: device name", "", " @tray-open: true if the tray has been opened or false if it has been closed", "", " Since: 1.1", "#"], qemu_type: Event(Event { name: "DEVICE_TRAY_MOVED", data: Object({"device": String("str"), "tray-open": String("bool")}) }) }, Section { description: [" -*- Mode: Python -*-", "", " QAPI block core definitions (vm unrelated)"], qemu_type: Include { name: "" } }, Section { description: ["#", " @SnapshotInfo", "", " @id: unique snapshot id", "", " @name: user chosen name", "", " @vm-state-size: size of the VM state", "", " @date-sec: UTC date of the snapshot in seconds", "", " @date-nsec: fractional part in nano seconds to be used with date-sec", "", " @vm-clock-sec: VM clock relative to boot in seconds", "", " @vm-clock-nsec: fractional part in nano seconds to be used with vm-clock-sec", "", " Since: 1.3", "", "#"], qemu_type: Struct(Struct { name: "SnapshotInfo", fields: Object({"date-nsec": String("int"), "date-sec": String("int"), "id": String("str"), "name": String("str"), "vm-clock-nsec": String("int"), "vm-clock-sec": String("int"), "vm-state-size": String("int")}), base: Null }) }, Section { description: ["#", " @ImageInfoSpecificQCow2:", "", " @compat: compatibility level", "", " @lazy-refcounts: #optional on or off; only valid for compat >= 1.1", "", " @corrupt: #optional true if the image has been marked corrupt; only valid for", "           compat >= 1.1 (since 2.2)", "", " @refcount-bits: width of a refcount entry in bits (since 2.3)", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "ImageInfoSpecificQCow2", fields: Object({"*corrupt": String("bool"), "*lazy-refcounts": String("bool"), "compat": String("str"), "refcount-bits": String("int")}), base: Null }) }, Section { description: ["#", " @ImageInfoSpecificVmdk:", "", " @create-type: The create type of VMDK image", "", " @cid: Content id of image", "", " @parent-cid: Parent VMDK image\"s cid", "", " @extents: List of extent files", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "ImageInfoSpecificVmdk", fields: Object({"cid": String("int"), "create-type": String("str"), "extents": Array([String("ImageInfo")]), "parent-cid": String("int")}), base: Null }) }, Section { description: ["#", " @ImageInfoSpecific:", "", " A discriminated record of image format specific information structures.", "", " Since: 1.7", "#"], qemu_type: Union(Union { name: "ImageInfoSpecific", discriminator: Null, data: Object({"qcow2": String("ImageInfoSpecificQCow2"), "vmdk": String("ImageInfoSpecificVmdk")}) }) }, Section { description: ["#", " @ImageInfo:", "", " Information about a QEMU image file", "", " @filename: name of the image file", "", " @format: format of the image file", "", " @virtual-size: maximum capacity in bytes of the image", "", " @actual-size: #optional actual size on disk in bytes of the image", "", " @dirty-flag: #optional true if image is not cleanly closed", "", " @cluster-size: #optional size of a cluster in bytes", "", " @encrypted: #optional true if the image is encrypted", "", " @compressed: #optional true if the image is compressed (Since 1.7)", "", " @backing-filename: #optional name of the backing file", "", " @full-backing-filename: #optional full path of the backing file", "", " @backing-filename-format: #optional the format of the backing file", "", " @snapshots: #optional list of VM snapshots", "", " @backing-image: #optional info of the backing image (since 1.6)", "", " @format-specific: #optional structure supplying additional format-specific", " information (since 1.7)", "", " Since: 1.3", "", "#"], qemu_type: Struct(Struct { name: "ImageInfo", fields: Object({"*actual-size": String("int"), "*backing-filename": String("str"), "*backing-filename-format": String("str"), "*backing-image": String("ImageInfo"), "*cluster-size": String("int"), "*compressed": String("bool"), "*dirty-flag": String("bool"), "*encrypted": String("bool"), "*format-specific": String("ImageInfoSpecific"), "*full-backing-filename": String("str"), "*snapshots": Array([String("SnapshotInfo")]), "filename": String("str"), "format": String("str"), "virtual-size": String("int")}), base: Null }) }, Section { description: ["#", " @ImageCheck:", "", " Information about a QEMU image file check", "", " @filename: name of the image file checked", "", " @format: format of the image file checked", "", " @check-errors: number of unexpected errors occurred during check", "", " @image-end-offset: #optional offset (in bytes) where the image ends, this", "                    field is present if the driver for the image format", "                    supports it", "", " @corruptions: #optional number of corruptions found during the check if any", "", " @leaks: #optional number of leaks found during the check if any", "", " @corruptions-fixed: #optional number of corruptions fixed during the check", "                     if any", "", " @leaks-fixed: #optional number of leaks fixed during the check if any", "", " @total-clusters: #optional total number of clusters, this field is present", "                  if the driver for the image format supports it", "", " @allocated-clusters: #optional total number of allocated clusters, this", "                      field is present if the driver for the image format", "                      supports it", "", " @fragmented-clusters: #optional total number of fragmented clusters, this", "                       field is present if the driver for the image format", "                       supports it", "", " @compressed-clusters: #optional total number of compressed clusters, this", "                       field is present if the driver for the image format", "                       supports it", "", " Since: 1.4", "", "#"], qemu_type: Struct(Struct { name: "ImageCheck", fields: Object({"*allocated-clusters": String("int"), "*compressed-clusters": String("int"), "*corruptions": String("int"), "*corruptions-fixed": String("int"), "*fragmented-clusters": String("int"), "*image-end-offset": String("int"), "*leaks": String("int"), "*leaks-fixed": String("int"), "*total-clusters": String("int"), "check-errors": String("int"), "filename": String("str"), "format": String("str")}), base: Null }) }, Section { description: ["#", " @BlockdevCacheInfo", "", " Cache mode information for a block device", "", " @writeback:   true if writeback mode is enabled", " @direct:      true if the host page cache is bypassed (O_DIRECT)", " @no-flush:    true if flush requests are ignored for the device", "", " Since: 2.3", "#"], qemu_type: Struct(Struct { name: "BlockdevCacheInfo", fields: Object({"direct": String("bool"), "no-flush": String("bool"), "writeback": String("bool")}), base: Null }) }, Section { description: ["#", " @BlockDeviceInfo:", "", " Information about the backing device for a block device.", "", " @file: the filename of the backing device", "", " @node-name: #optional the name of the block driver node (Since 2.0)", "", " @ro: true if the backing device was open read-only", "", " @drv: the name of the block format used to open the backing device. As of", "       0.14.0 this can be: \"blkdebug\", \"bochs\", \"cloop\", \"cow\", \"dmg\",", "       \"file\", \"file\", \"ftp\", \"ftps\", \"host_cdrom\", \"host_device\",", "       \"host_floppy\", \"http\", \"https\", \"nbd\", \"parallels\", \"qcow\",", "       \"qcow2\", \"raw\", \"tftp\", \"vdi\", \"vmdk\", \"vpc\", \"vvfat\"", "       2.2: \"archipelago\" added, \"cow\" dropped", "       2.3: \"host_floppy\" deprecated", "", " @backing_file: #optional the name of the backing file (for copy-on-write)", "", " @backing_file_depth: number of files in the backing file chain (since: 1.2)", "", " @encrypted: true if the backing device is encrypted", "", " @encryption_key_missing: true if the backing device is encrypted but an", "                          valid encryption key is missing", "", " @detect_zeroes: detect and optimize zero writes (Since 2.1)", "", " @bps: total throughput limit in bytes per second is specified", "", " @bps_rd: read throughput limit in bytes per second is specified", "", " @bps_wr: write throughput limit in bytes per second is specified", "", " @iops: total I/O operations per second is specified", "", " @iops_rd: read I/O operations per second is specified", "", " @iops_wr: write I/O operations per second is specified", "", " @image: the info of image used (since: 1.6)", "", " @bps_max: #optional total max in bytes (Since 1.7)", "", " @bps_rd_max: #optional read max in bytes (Since 1.7)", "", " @bps_wr_max: #optional write max in bytes (Since 1.7)", "", " @iops_max: #optional total I/O operations max (Since 1.7)", "", " @iops_rd_max: #optional read I/O operations max (Since 1.7)", "", " @iops_wr_max: #optional write I/O operations max (Since 1.7)", "", " @iops_size: #optional an I/O size in bytes (Since 1.7)", "", " @cache: the cache mode used for the block device (since: 2.3)", "", " @write_threshold: configured write threshold for the device.", "                   0 if disabled. (Since 2.3)", "", " Since: 0.14.0", "", "#"], qemu_type: Struct(Struct { name: "BlockDeviceInfo", fields: Object({"*backing_file": String("str"), "*bps_max": String("int"), "*bps_rd_max": String("int"), "*bps_wr_max": String("int"), "*iops_max": String("int"), "*iops_rd_max": String("int"), "*iops_size": String("int"), "*iops_wr_max": String("int"), "*node-name": String("str"), "backing_file_depth": String("int"), "bps": String("int"), "bps_rd": String("int"), "bps_wr": String("int"), "cache": String("BlockdevCacheInfo"), "detect_zeroes": String("BlockdevDetectZeroesOptions"), "drv": String("str"), "encrypted": String("bool"), "encryption_key_missing": String("bool"), "file": String("str"), "image": String("ImageInfo"), "iops": String("int"), "iops_rd": String("int"), "iops_wr": String("int"), "ro": String("bool"), "write_threshold": String("int")}), base: Null }) }, Section { description: ["#", " @BlockDeviceIoStatus:", "", " An enumeration of block device I/O status.", "", " @ok: The last I/O operation has succeeded", "", " @failed: The last I/O operation has failed", "", " @nospace: The last I/O operation has failed due to a no-space condition", "", " Since: 1.0", "#"], qemu_type: Enum(Enum { name: "BlockDeviceIoStatus", fields: Array([String("ok"), String("failed"), String("nospace")]) }) }, Section { description: ["#", " @BlockDeviceMapEntry:", "", " Entry in the metadata map of the device (returned by \"qemu-img map\")", "", " @start: Offset in the image of the first byte described by this entry", "         (in bytes)", "", " @length: Length of the range described by this entry (in bytes)", "", " @depth: Number of layers (0 = top image, 1 = top image\"s backing file, etc.)", "         before reaching one for which the range is allocated.  The value is", "         in the range 0 to the depth of the image chain - 1.", "", " @zero: the sectors in this range read as zeros", "", " @data: reading the image will actually read data from a file (in particular,", "        if @offset is present this means that the sectors are not simply", "        preallocated, but contain actual data in raw format)", "", " @offset: if present, the image file stores the data for this range in", "          raw format at the given offset.", "", " Since 1.7", "#"], qemu_type: Struct(Struct { name: "BlockDeviceMapEntry", fields: Object({"*offset": String("int"), "data": String("bool"), "depth": String("int"), "length": String("int"), "start": String("int"), "zero": String("bool")}), base: Null }) }, Section { description: ["#", " @BlockDirtyInfo:", "", " Block dirty bitmap information.", "", " @name: #optional the name of the dirty bitmap (Since 2.4)", "", " @count: number of dirty bytes according to the dirty bitmap", "", " @granularity: granularity of the dirty bitmap in bytes (since 1.4)", "", " @frozen: whether the dirty bitmap is frozen (Since 2.4)", "", " Since: 1.3", "#"], qemu_type: Struct(Struct { name: "BlockDirtyInfo", fields: Object({"*name": String("str"), "count": String("int"), "frozen": String("bool"), "granularity": String("uint32")}), base: Null }) }, Section { description: ["#", " @BlockInfo:", "", " Block device information.  This structure describes a virtual device and", " the backing device associated with it.", "", " @device: The device name associated with the virtual device.", "", " @type: This field is returned only for compatibility reasons, it should", "        not be used (always returns \"unknown\")", "", " @removable: True if the device supports removable media.", "", " @locked: True if the guest has locked this device from having its media", "          removed", "", " @tray_open: #optional True if the device has a tray and it is open", "             (only present if removable is true)", "", " @dirty-bitmaps: #optional dirty bitmaps information (only present if the", "                 driver has one or more dirty bitmaps) (Since 2.0)", "", " @io-status: #optional @BlockDeviceIoStatus. Only present if the device", "             supports it and the VM is configured to stop on errors", "             (supported device models: virtio-blk, ide, scsi-disk)", "", " @inserted: #optional @BlockDeviceInfo describing the device if media is", "            present", "", " Since:  0.14.0", "#"], qemu_type: Struct(Struct { name: "BlockInfo", fields: Object({"*dirty-bitmaps": Array([String("BlockDirtyInfo")]), "*inserted": String("BlockDeviceInfo"), "*io-status": String("BlockDeviceIoStatus"), "*tray_open": String("bool"), "device": String("str"), "locked": String("bool"), "removable": String("bool"), "type": String("str")}), base: Null }) }, Section { description: ["#", " @query-block:", "", " Get a list of BlockInfo for all virtual block devices.", "", " Returns: a list of @BlockInfo describing each virtual block device", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-block", fields: Null, gen: Null, returns: Array([String("BlockInfo")]) }) }, Section { description: ["#", " @BlockDeviceStats:", "", " Statistics of a virtual block device or a block backing device.", "", " @rd_bytes:      The number of bytes read by the device.", "", " @wr_bytes:      The number of bytes written by the device.", "", " @rd_operations: The number of read operations performed by the device.", "", " @wr_operations: The number of write operations performed by the device.", "", " @flush_operations: The number of cache flush operations performed by the", "                    device (since 0.15.0)", "", " @flush_total_time_ns: Total time spend on cache flushes in nano-seconds", "                       (since 0.15.0).", "", " @wr_total_time_ns: Total time spend on writes in nano-seconds (since 0.15.0).", "", " @rd_total_time_ns: Total_time_spend on reads in nano-seconds (since 0.15.0).", "", " @wr_highest_offset: The offset after the greatest byte written to the", "                     device.  The intended use of this information is for", "                     growable sparse files (like qcow2) that are used on top", "                     of a physical device.", "", " @rd_merged: Number of read requests that have been merged into another", "             request (Since 2.3).", "", " @wr_merged: Number of write requests that have been merged into another", "             request (Since 2.3).", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "BlockDeviceStats", fields: Object({"flush_operations": String("int"), "flush_total_time_ns": String("int"), "rd_bytes": String("int"), "rd_merged": String("int"), "rd_operations": String("int"), "rd_total_time_ns": String("int"), "wr_bytes": String("int"), "wr_highest_offset": String("int"), "wr_merged": String("int"), "wr_operations": String("int"), "wr_total_time_ns": String("int")}), base: Null }) }, Section { description: ["#", " @BlockStats:", "", " Statistics of a virtual block device or a block backing device.", "", " @device: #optional If the stats are for a virtual block device, the name", "          corresponding to the virtual block device.", "", " @node-name: #optional The node name of the device. (Since 2.3)", "", " @stats:  A @BlockDeviceStats for the device.", "", " @parent: #optional This describes the file block device if it has one.", "", " @backing: #optional This describes the backing block device if it has one.", "           (Since 2.0)", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "BlockStats", fields: Object({"*backing": String("BlockStats"), "*device": String("str"), "*node-name": String("str"), "*parent": String("BlockStats"), "stats": String("BlockDeviceStats")}), base: Null }) }, Section { description: ["#", " @query-blockstats:", "", " Query the @BlockStats for all virtual block devices.", "", " @query-nodes: #optional If true, the command will query all the block nodes", "               that have a node name, in a list which will include \"parent\"", "               information, but not \"backing\".", "               If false or omitted, the behavior is as before - query all the", "               device backends, recursively including their \"parent\" and", "               \"backing\". (Since 2.3)", "", " Returns: A list of @BlockStats for each virtual block devices.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-blockstats", fields: Object({"*query-nodes": String("bool")}), gen: Null, returns: Array([String("BlockStats")]) }) }, Section { description: ["#", " @BlockdevOnError:", "", " An enumeration of possible behaviors for errors on I/O operations.", " The exact meaning depends on whether the I/O was initiated by a guest", " or by a block job", "", " @report: for guest operations, report the error to the guest;", "          for jobs, cancel the job", "", " @ignore: ignore the error, only report a QMP event (BLOCK_IO_ERROR", "          or BLOCK_JOB_ERROR)", "", " @enospc: same as @stop on ENOSPC, same as @report otherwise.", "", " @stop: for guest operations, stop the virtual machine;", "        for jobs, pause the job", "", " Since: 1.3", "#"], qemu_type: Enum(Enum { name: "BlockdevOnError", fields: Array([String("report"), String("ignore"), String("enospc"), String("stop")]) }) }, Section { description: ["#", " @MirrorSyncMode:", "", " An enumeration of possible behaviors for the initial synchronization", " phase of storage mirroring.", "", " @top: copies data in the topmost image to the destination", "", " @full: copies data from all images to the destination", "", " @none: only copy data written from now on", "", " @dirty-bitmap: only copy data described by the dirty bitmap. Since: 2.4", "", " Since: 1.3", "#"], qemu_type: Enum(Enum { name: "MirrorSyncMode", fields: Array([String("top"), String("full"), String("none"), String("dirty-bitmap")]) }) }, Section { description: ["#", " @BlockJobType:", "", " Type of a block job.", "", " @commit: block commit job type, see \"block-commit\"", "", " @stream: block stream job type, see \"block-stream\"", "", " @mirror: drive mirror job type, see \"drive-mirror\"", "", " @backup: drive backup job type, see \"drive-backup\"", "", " Since: 1.7", "#"], qemu_type: Enum(Enum { name: "BlockJobType", fields: Array([String("commit"), String("stream"), String("mirror"), String("backup")]) }) }, Section { description: ["#", " @BlockJobInfo:", "", " Information about a long-running block device operation.", "", " @type: the job type (\"stream\" for image streaming)", "", " @device: the block device name", "", " @len: the maximum progress value", "", " @busy: false if the job is known to be in a quiescent state, with", "        no pending I/O.  Since 1.3.", "", " @paused: whether the job is paused or, if @busy is true, will", "          pause itself as soon as possible.  Since 1.3.", "", " @offset: the current progress value", "", " @speed: the rate limit, bytes per second", "", " @io-status: the status of the job (since 1.3)", "", " @ready: true if the job may be completed (since 2.2)", "", " Since: 1.1", "#"], qemu_type: Struct(Struct { name: "BlockJobInfo", fields: Object({"busy": String("bool"), "device": String("str"), "io-status": String("BlockDeviceIoStatus"), "len": String("int"), "offset": String("int"), "paused": String("bool"), "ready": String("bool"), "speed": String("int"), "type": String("str")}), base: Null }) }, Section { description: ["#", " @query-block-jobs:", "", " Return information about long-running block device operations.", "", " Returns: a list of @BlockJobInfo for each active block job", "", " Since: 1.1", "#"], qemu_type: Command(Command { name: "query-block-jobs", fields: Null, gen: Null, returns: Array([String("BlockJobInfo")]) }) }, Section { description: ["#", " @block_passwd:", "", " This command sets the password of a block device that has not been open", " with a password and requires one.", "", " The two cases where this can happen are a block device is created through", " QEMU\"s initial command line or a block device is changed through the legacy", " @change interface.", "", " In the event that the block device is created through the initial command", " line, the VM will start in the stopped state regardless of whether \"-S\" is", " used.  The intention is for a management tool to query the block devices to", " determine which ones are encrypted, set the passwords with this command, and", " then start the guest with the @cont command.", "", " Either @device or @node-name must be set but not both.", "", " @device: #optional the name of the block backend device to set the password on", "", " @node-name: #optional graph node name to set the password on (Since 2.0)", "", " @password: the password to use for the device", "", " Returns: nothing on success", "          If @device is not a valid block device, DeviceNotFound", "          If @device is not encrypted, DeviceNotEncrypted", "", " Notes:  Not all block formats support encryption and some that do are not", "         able to validate that a password is correct.  Disk corruption may", "         occur if an invalid password is specified.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "block_passwd", fields: Object({"*device": String("str"), "*node-name": String("str"), "password": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @block_resize", "", " Resize a block image while a guest is running.", "", " Either @device or @node-name must be set but not both.", "", " @device: #optional the name of the device to get the image resized", "", " @node-name: #optional graph node name to get the image resized (Since 2.0)", "", " @size:  new image size in bytes", "", " Returns: nothing on success", "          If @device is not a valid block device, DeviceNotFound", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "block_resize", fields: Object({"*device": String("str"), "*node-name": String("str"), "size": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @NewImageMode", "", " An enumeration that tells QEMU how to set the backing file path in", " a new image file.", "", " @existing: QEMU should look for an existing image file.", "", " @absolute-paths: QEMU should create a new image with absolute paths", " for the backing file. If there is no backing file available, the new", " image will not be backed either.", "", " Since: 1.1", "#"], qemu_type: Enum(Enum { name: "NewImageMode", fields: Array([String("existing"), String("absolute-paths")]) }) }, Section { description: ["#", " @BlockdevSnapshot", "", " Either @device or @node-name must be set but not both.", "", " @device: #optional the name of the device to generate the snapshot from.", "", " @node-name: #optional graph node name to generate the snapshot from (Since 2.0)", "", " @snapshot-file: the target of the new image. A new file will be created.", "", " @snapshot-node-name: #optional the graph node name of the new image (Since 2.0)", "", " @format: #optional the format of the snapshot image, default is \"qcow2\".", "", " @mode: #optional whether and how QEMU should create a new image, default is", "        \"absolute-paths\".", "#"], qemu_type: Struct(Struct { name: "BlockdevSnapshot", fields: Object({"*device": String("str"), "*format": String("str"), "*mode": String("NewImageMode"), "*node-name": String("str"), "*snapshot-node-name": String("str"), "snapshot-file": String("str")}), base: Null }) }, Section { description: ["#", " @DriveBackup", "", " @device: the name of the device which should be copied.", "", " @target: the target of the new image. If the file exists, or if it", "          is a device, the existing file/device will be used as the new", "          destination.  If it does not exist, a new file will be created.", "", " @format: #optional the format of the new destination, default is to", "          probe if @mode is \"existing\", else the format of the source", "", " @sync: what parts of the disk image should be copied to the destination", "        (all the disk, only the sectors allocated in the topmost image, from a", "        dirty bitmap, or only new I/O).", "", " @mode: #optional whether and how QEMU should create a new image, default is", "        \"absolute-paths\".", "", " @speed: #optional the maximum speed, in bytes per second", "", " @bitmap: #optional the name of dirty bitmap if sync is \"dirty-bitmap\".", "          Must be present if sync is \"dirty-bitmap\", must NOT be present", "          otherwise. (Since 2.4)", "", " @on-source-error: #optional the action to take on an error on the source,", "                   default \"report\".  \"stop\" and \"enospc\" can only be used", "                   if the block device supports io-status (see BlockInfo).", "", " @on-target-error: #optional the action to take on an error on the target,", "                   default \"report\" (no limitations, since this applies to", "                   a different block device than @device).", "", " Note that @on-source-error and @on-target-error only affect background I/O.", " If an error occurs during a guest write request, the device\"s rerror/werror", " actions will be used.", "", " Since: 1.6", "#"], qemu_type: Struct(Struct { name: "DriveBackup", fields: Object({"*bitmap": String("str"), "*format": String("str"), "*mode": String("NewImageMode"), "*on-source-error": String("BlockdevOnError"), "*on-target-error": String("BlockdevOnError"), "*speed": String("int"), "device": String("str"), "sync": String("MirrorSyncMode"), "target": String("str")}), base: Null }) }, Section { description: ["#", " @BlockdevBackup", "", " @device: the name of the device which should be copied.", "", " @target: the name of the backup target device.", "", " @sync: what parts of the disk image should be copied to the destination", "        (all the disk, only the sectors allocated in the topmost image, or", "        only new I/O).", "", " @speed: #optional the maximum speed, in bytes per second. The default is 0,", "         for unlimited.", "", " @on-source-error: #optional the action to take on an error on the source,", "                   default \"report\".  \"stop\" and \"enospc\" can only be used", "                   if the block device supports io-status (see BlockInfo).", "", " @on-target-error: #optional the action to take on an error on the target,", "                   default \"report\" (no limitations, since this applies to", "                   a different block device than @device).", "", " Note that @on-source-error and @on-target-error only affect background I/O.", " If an error occurs during a guest write request, the device\"s rerror/werror", " actions will be used.", "", " Since: 2.3", "#"], qemu_type: Struct(Struct { name: "BlockdevBackup", fields: Object({"*on-source-error": String("BlockdevOnError"), "*on-target-error": String("BlockdevOnError"), "*speed": String("int"), "device": String("str"), "sync": String("MirrorSyncMode"), "target": String("str")}), base: Null }) }, Section { description: ["#", " @blockdev-snapshot-sync", "", " Generates a synchronous snapshot of a block device.", "", " For the arguments, see the documentation of BlockdevSnapshot.", "", " Returns: nothing on success", "          If @device is not a valid block device, DeviceNotFound", "", " Since 0.14.0", "#"], qemu_type: Command(Command { name: "blockdev-snapshot-sync", fields: String("BlockdevSnapshot"), gen: Null, returns: Null }) }, Section { description: ["#", " @change-backing-file", "", " Change the backing file in the image file metadata.  This does not", " cause QEMU to reopen the image file to reparse the backing filename", " (it may, however, perform a reopen to change permissions from", " r/o -> r/w -> r/o, if needed). The new backing file string is written", " into the image file metadata, and the QEMU internal strings are", " updated.", "", " @image-node-name: The name of the block driver state node of the", "                   image to modify.", "", " @device:          The name of the device that owns image-node-name.", "", " @backing-file:    The string to write as the backing file.  This", "                   string is not validated, so care should be taken", "                   when specifying the string or the image chain may", "                   not be able to be reopened again.", "", " Since: 2.1", "#"], qemu_type: Command(Command { name: "change-backing-file", fields: Object({"backing-file": String("str"), "device": String("str"), "image-node-name": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @block-commit", "", " Live commit of data from overlay image nodes into backing nodes - i.e.,", " writes data between \"top\" and \"base\" into \"base\".", "", " @device:  the name of the device", "", " @base:   #optional The file name of the backing image to write data into.", "                    If not specified, this is the deepest backing image", "", " @top:    #optional The file name of the backing image within the image chain,", "                    which contains the topmost data to be committed down. If", "                    not specified, this is the active layer.", "", " @backing-file:  #optional The backing file string to write into the overlay", "                           image of \"top\".  If \"top\" is the active layer,", "                           specifying a backing file string is an error. This", "                           filename is not validated.", "", "                           If a pathname string is such that it cannot be", "                           resolved by QEMU, that means that subsequent QMP or", "                           HMP commands must use node-names for the image in", "                           question, as filename lookup methods will fail.", "", "                           If not specified, QEMU will automatically determine", "                           the backing file string to use, or error out if", "                           there is no obvious choice. Care should be taken", "                           when specifying the string, to specify a valid", "                           filename or protocol.", "                           (Since 2.1)", "", "                    If top == base, that is an error.", "                    If top == active, the job will not be completed by itself,", "                    user needs to complete the job with the block-job-complete", "                    command after getting the ready event. (Since 2.0)", "", "                    If the base image is smaller than top, then the base image", "                    will be resized to be the same size as top.  If top is", "                    smaller than the base image, the base will not be", "                    truncated.  If you want the base image size to match the", "                    size of the smaller top, you can safely truncate it", "                    yourself once the commit operation successfully completes.", "", " @speed:  #optional the maximum speed, in bytes per second", "", " Returns: Nothing on success", "          If commit or stream is already active on this device, DeviceInUse", "          If @device does not exist, DeviceNotFound", "          If image commit is not supported by this device, NotSupported", "          If @base or @top is invalid, a generic error is returned", "          If @speed is invalid, InvalidParameter", "", " Since: 1.3", "", "#"], qemu_type: Command(Command { name: "block-commit", fields: Object({"*backing-file": String("str"), "*base": String("str"), "*speed": String("int"), "*top": String("str"), "device": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @drive-backup", "", " Start a point-in-time copy of a block device to a new destination.  The", " status of ongoing drive-backup operations can be checked with", " query-block-jobs where the BlockJobInfo.type field has the value \"backup\".", " The operation can be stopped before it has completed using the", " block-job-cancel command.", "", " For the arguments, see the documentation of DriveBackup.", "", " Returns: nothing on success", "          If @device is not a valid block device, DeviceNotFound", "", " Since 1.6", "#"], qemu_type: Command(Command { name: "drive-backup", fields: String("DriveBackup"), gen: Null, returns: Null }) }, Section { description: ["#", " @blockdev-backup", "", " Start a point-in-time copy of a block device to a new destination.  The", " status of ongoing blockdev-backup operations can be checked with", " query-block-jobs where the BlockJobInfo.type field has the value \"backup\".", " The operation can be stopped before it has completed using the", " block-job-cancel command.", "", " For the arguments, see the documentation of BlockdevBackup.", "", " Since 2.3", "#"], qemu_type: Command(Command { name: "blockdev-backup", fields: String("BlockdevBackup"), gen: Null, returns: Null }) }, Section { description: ["#", " @query-named-block-nodes", "", " Get the named block driver list", "", " Returns: the list of BlockDeviceInfo", "", " Since 2.0", "#"], qemu_type: Command(Command { name: "query-named-block-nodes", fields: Null, gen: Null, returns: Array([String("BlockDeviceInfo")]) }) }, Section { description: ["#", " @drive-mirror", "", " Start mirroring a block device\"s writes to a new destination.", "", " @device:  the name of the device whose writes should be mirrored.", "", " @target: the target of the new image. If the file exists, or if it", "          is a device, the existing file/device will be used as the new", "          destination.  If it does not exist, a new file will be created.", "", " @format: #optional the format of the new destination, default is to", "          probe if @mode is \"existing\", else the format of the source", "", " @node-name: #optional the new block driver state node name in the graph", "             (Since 2.1)", "", " @replaces: #optional with sync=full graph node name to be replaced by the new", "            image when a whole image copy is done. This can be used to repair", "            broken Quorum files. (Since 2.1)", "", " @mode: #optional whether and how QEMU should create a new image, default is", "        \"absolute-paths\".", "", " @speed:  #optional the maximum speed, in bytes per second", "", " @sync: what parts of the disk image should be copied to the destination", "        (all the disk, only the sectors allocated in the topmost image, or", "        only new I/O).", "", " @granularity: #optional granularity of the dirty bitmap, default is 64K", "               if the image format doesn\"t have clusters, 4K if the clusters", "               are smaller than that, else the cluster size.  Must be a", "               power of 2 between 512 and 64M (since 1.4).", "", " @buf-size: #optional maximum amount of data in flight from source to", "            target (since 1.4).", "", " @on-source-error: #optional the action to take on an error on the source,", "                   default \"report\".  \"stop\" and \"enospc\" can only be used", "                   if the block device supports io-status (see BlockInfo).", "", " @on-target-error: #optional the action to take on an error on the target,", "                   default \"report\" (no limitations, since this applies to", "                   a different block device than @device).", "", " Returns: nothing on success", "          If @device is not a valid block device, DeviceNotFound", "", " Since 1.3", "#"], qemu_type: Command(Command { name: "drive-mirror", fields: Object({"*buf-size": String("int"), "*format": String("str"), "*granularity": String("uint32"), "*mode": String("NewImageMode"), "*node-name": String("str"), "*on-source-error": String("BlockdevOnError"), "*on-target-error": String("BlockdevOnError"), "*replaces": String("str"), "*speed": String("int"), "device": String("str"), "sync": String("MirrorSyncMode"), "target": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @BlockDirtyBitmap", "", " @node: name of device/node which the bitmap is tracking", "", " @name: name of the dirty bitmap", "", " Since 2.4", "#"], qemu_type: Struct(Struct { name: "BlockDirtyBitmap", fields: Object({"name": String("str"), "node": String("str")}), base: Null }) }, Section { description: ["#", " @BlockDirtyBitmapAdd", "", " @node: name of device/node which the bitmap is tracking", "", " @name: name of the dirty bitmap", "", " @granularity: #optional the bitmap granularity, default is 64k for", "               block-dirty-bitmap-add", "", " Since 2.4", "#"], qemu_type: Struct(Struct { name: "BlockDirtyBitmapAdd", fields: Object({"*granularity": String("uint32"), "name": String("str"), "node": String("str")}), base: Null }) }, Section { description: ["#", " @block-dirty-bitmap-add", "", " Create a dirty bitmap with a name on the node", "", " Returns: nothing on success", "          If @node is not a valid block device or node, DeviceNotFound", "          If @name is already taken, GenericError with an explanation", "", " Since 2.4", "#"], qemu_type: Command(Command { name: "block-dirty-bitmap-add", fields: String("BlockDirtyBitmapAdd"), gen: Null, returns: Null }) }, Section { description: ["#", " @block-dirty-bitmap-remove", "", " Remove a dirty bitmap on the node", "", " Returns: nothing on success", "          If @node is not a valid block device or node, DeviceNotFound", "          If @name is not found, GenericError with an explanation", "          if @name is frozen by an operation, GenericError", "", " Since 2.4", "#"], qemu_type: Command(Command { name: "block-dirty-bitmap-remove", fields: String("BlockDirtyBitmap"), gen: Null, returns: Null }) }, Section { description: ["#", " @block-dirty-bitmap-clear", "", " Clear (reset) a dirty bitmap on the device", "", " Returns: nothing on success", "          If @node is not a valid block device, DeviceNotFound", "          If @name is not found, GenericError with an explanation", "", " Since 2.4", "#"], qemu_type: Command(Command { name: "block-dirty-bitmap-clear", fields: String("BlockDirtyBitmap"), gen: Null, returns: Null }) }, Section { description: ["#", " @block_set_io_throttle:", "", " Change I/O throttle limits for a block drive.", "", " @device: The name of the device", "", " @bps: total throughput limit in bytes per second", "", " @bps_rd: read throughput limit in bytes per second", "", " @bps_wr: write throughput limit in bytes per second", "", " @iops: total I/O operations per second", "", " @ops_rd: read I/O operations per second", "", " @iops_wr: write I/O operations per second", "", " @bps_max: #optional total max in bytes (Since 1.7)", "", " @bps_rd_max: #optional read max in bytes (Since 1.7)", "", " @bps_wr_max: #optional write max in bytes (Since 1.7)", "", " @iops_max: #optional total I/O operations max (Since 1.7)", "", " @iops_rd_max: #optional read I/O operations max (Since 1.7)", "", " @iops_wr_max: #optional write I/O operations max (Since 1.7)", "", " @iops_size: #optional an I/O size in bytes (Since 1.7)", "", " Returns: Nothing on success", "          If @device is not a valid block device, DeviceNotFound", "", " Since: 1.1", "#"], qemu_type: Command(Command { name: "block_set_io_throttle", fields: Object({"*bps_max": String("int"), "*bps_rd_max": String("int"), "*bps_wr_max": String("int"), "*iops_max": String("int"), "*iops_rd_max": String("int"), "*iops_size": String("int"), "*iops_wr_max": String("int"), "bps": String("int"), "bps_rd": String("int"), "bps_wr": String("int"), "device": String("str"), "iops": String("int"), "iops_rd": String("int"), "iops_wr": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @block-stream:", "", " Copy data from a backing file into a block device.", "", " The block streaming operation is performed in the background until the entire", " backing file has been copied.  This command returns immediately once streaming", " has started.  The status of ongoing block streaming operations can be checked", " with query-block-jobs.  The operation can be stopped before it has completed", " using the block-job-cancel command.", "", " If a base file is specified then sectors are not copied from that base file and", " its backing chain.  When streaming completes the image file will have the base", " file as its backing file.  This can be used to stream a subset of the backing", " file chain instead of flattening the entire image.", "", " On successful completion the image file is updated to drop the backing file", " and the BLOCK_JOB_COMPLETED event is emitted.", "", " @device: the device name", "", " @base:   #optional the common backing file name", "", " @backing-file: #optional The backing file string to write into the active", "                          layer. This filename is not validated.", "", "                          If a pathname string is such that it cannot be", "                          resolved by QEMU, that means that subsequent QMP or", "                          HMP commands must use node-names for the image in", "                          question, as filename lookup methods will fail.", "", "                          If not specified, QEMU will automatically determine", "                          the backing file string to use, or error out if there", "                          is no obvious choice.  Care should be taken when", "                          specifying the string, to specify a valid filename or", "                          protocol.", "                          (Since 2.1)", "", " @speed:  #optional the maximum speed, in bytes per second", "", " @on-error: #optional the action to take on an error (default report).", "            \"stop\" and \"enospc\" can only be used if the block device", "            supports io-status (see BlockInfo).  Since 1.3.", "", " Returns: Nothing on success", "          If @device does not exist, DeviceNotFound", "", " Since: 1.1", "#"], qemu_type: Command(Command { name: "block-stream", fields: Object({"*backing-file": String("str"), "*base": String("str"), "*on-error": String("BlockdevOnError"), "*speed": String("int"), "device": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @block-job-set-speed:", "", " Set maximum speed for a background block operation.", "", " This command can only be issued when there is an active block job.", "", " Throttling can be disabled by setting the speed to 0.", "", " @device: the device name", "", " @speed:  the maximum speed, in bytes per second, or 0 for unlimited.", "          Defaults to 0.", "", " Returns: Nothing on success", "          If no background operation is active on this device, DeviceNotActive", "", " Since: 1.1", "#"], qemu_type: Command(Command { name: "block-job-set-speed", fields: Object({"device": String("str"), "speed": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @block-job-cancel:", "", " Stop an active background block operation.", "", " This command returns immediately after marking the active background block", " operation for cancellation.  It is an error to call this command if no", " operation is in progress.", "", " The operation will cancel as soon as possible and then emit the", " BLOCK_JOB_CANCELLED event.  Before that happens the job is still visible when", " enumerated using query-block-jobs.", "", " For streaming, the image file retains its backing file unless the streaming", " operation happens to complete just as it is being cancelled.  A new streaming", " operation can be started at a later time to finish copying all data from the", " backing file.", "", " @device: the device name", "", " @force: #optional whether to allow cancellation of a paused job (default", "         false).  Since 1.3.", "", " Returns: Nothing on success", "          If no background operation is active on this device, DeviceNotActive", "", " Since: 1.1", "#"], qemu_type: Command(Command { name: "block-job-cancel", fields: Object({"*force": String("bool"), "device": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @block-job-pause:", "", " Pause an active background block operation.", "", " This command returns immediately after marking the active background block", " operation for pausing.  It is an error to call this command if no", " operation is in progress.  Pausing an already paused job has no cumulative", " effect; a single block-job-resume command will resume the job.", "", " The operation will pause as soon as possible.  No event is emitted when", " the operation is actually paused.  Cancelling a paused job automatically", " resumes it.", "", " @device: the device name", "", " Returns: Nothing on success", "          If no background operation is active on this device, DeviceNotActive", "", " Since: 1.3", "#"], qemu_type: Command(Command { name: "block-job-pause", fields: Object({"device": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @block-job-resume:", "", " Resume an active background block operation.", "", " This command returns immediately after resuming a paused background block", " operation.  It is an error to call this command if no operation is in", " progress.  Resuming an already running job is not an error.", "", " This command also clears the error status of the job.", "", " @device: the device name", "", " Returns: Nothing on success", "          If no background operation is active on this device, DeviceNotActive", "", " Since: 1.3", "#"], qemu_type: Command(Command { name: "block-job-resume", fields: Object({"device": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @block-job-complete:", "", " Manually trigger completion of an active background block operation.  This", " is supported for drive mirroring, where it also switches the device to", " write to the target path only.  The ability to complete is signaled with", " a BLOCK_JOB_READY event.", "", " This command completes an active background block operation synchronously.", " The ordering of this command\"s return with the BLOCK_JOB_COMPLETED event", " is not defined.  Note that if an I/O error occurs during the processing of", " this command: 1) the command itself will fail; 2) the error will be processed", " according to the rerror/werror arguments that were specified when starting", " the operation.", "", " A cancelled or paused job cannot be completed.", "", " @device: the device name", "", " Returns: Nothing on success", "          If no background operation is active on this device, DeviceNotActive", "", " Since: 1.3", "#"], qemu_type: Command(Command { name: "block-job-complete", fields: Object({"device": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @BlockdevDiscardOptions", "", " Determines how to handle discard requests.", "", " @ignore:      Ignore the request", " @unmap:       Forward as an unmap request", "", " Since: 1.7", "#"], qemu_type: Enum(Enum { name: "BlockdevDiscardOptions", fields: Array([String("ignore"), String("unmap")]) }) }, Section { description: ["#", " @BlockdevDetectZeroesOptions", "", " Describes the operation mode for the automatic conversion of plain", " zero writes by the OS to driver specific optimized zero write commands.", "", " @off:      Disabled (default)", " @on:       Enabled", " @unmap:    Enabled and even try to unmap blocks if possible. This requires", "            also that @BlockdevDiscardOptions is set to unmap for this device.", "", " Since: 2.1", "#"], qemu_type: Enum(Enum { name: "BlockdevDetectZeroesOptions", fields: Array([String("off"), String("on"), String("unmap")]) }) }, Section { description: ["#", " @BlockdevAioOptions", "", " Selects the AIO backend to handle I/O requests", "", " @threads:     Use qemu\"s thread pool", " @native:      Use native AIO backend (only Linux and Windows)", "", " Since: 1.7", "#"], qemu_type: Enum(Enum { name: "BlockdevAioOptions", fields: Array([String("threads"), String("native")]) }) }, Section { description: ["#", " @BlockdevCacheOptions", "", " Includes cache-related options for block devices", "", " @writeback:   #optional enables writeback mode for any caches (default: true)", " @direct:      #optional enables use of O_DIRECT (bypass the host page cache;", "               default: false)", " @no-flush:    #optional ignore any flush requests for the device (default:", "               false)", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "BlockdevCacheOptions", fields: Object({"*direct": String("bool"), "*no-flush": String("bool"), "*writeback": String("bool")}), base: Null }) }, Section { description: ["#", " @BlockdevDriver", "", " Drivers that are supported in block device operations.", "", " @host_device, @host_cdrom, @host_floppy: Since 2.1", " @host_floppy: deprecated since 2.3", "", " Since: 2.0", "#"], qemu_type: Enum(Enum { name: "BlockdevDriver", fields: Array([String("archipelago"), String("blkdebug"), String("blkverify"), String("bochs"), String("cloop"), String("dmg"), String("file"), String("ftp"), String("ftps"), String("host_cdrom"), String("host_device"), String("host_floppy"), String("http"), String("https"), String("null-aio"), String("null-co"), String("parallels"), String("qcow"), String("qcow2"), String("qed"), String("quorum"), String("raw"), String("tftp"), String("vdi"), String("vhdx"), String("vmdk"), String("vpc"), String("vvfat")]) }) }, Section { description: ["#", " @BlockdevOptionsBase", "", " Options that are available for all block devices, independent of the block", " driver.", "", " @driver:        block driver name", " @id:            #optional id by which the new block device can be referred to.", "                 This is a required option on the top level of blockdev-add, and", "                 currently not allowed on any other level.", " @node-name:     #optional the name of a block driver state node (Since 2.0)", " @discard:       #optional discard-related options (default: ignore)", " @cache:         #optional cache-related options", " @aio:           #optional AIO backend (default: threads)", " @rerror:        #optional how to handle read errors on the device", "                 (default: report)", " @werror:        #optional how to handle write errors on the device", "                 (default: enospc)", " @read-only:     #optional whether the block device should be read-only", "                 (default: false)", " @detect-zeroes: #optional detect and optimize zero writes (Since 2.1)", "                 (default: off)", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsBase", fields: Object({"*aio": String("BlockdevAioOptions"), "*cache": String("BlockdevCacheOptions"), "*detect-zeroes": String("BlockdevDetectZeroesOptions"), "*discard": String("BlockdevDiscardOptions"), "*id": String("str"), "*node-name": String("str"), "*read-only": String("bool"), "*rerror": String("BlockdevOnError"), "*werror": String("BlockdevOnError"), "driver": String("BlockdevDriver")}), base: Null }) }, Section { description: ["#", " @BlockdevOptionsFile", "", " Driver specific block device options for the file backend and similar", " protocols.", "", " @filename:    path to the image file", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsFile", fields: Object({"filename": String("str")}), base: Null }) }, Section { description: ["#", " @BlockdevOptionsNull", "", " Driver specific block device options for the null backend.", "", " @size:    #optional size of the device in bytes.", " @latency-ns: #optional emulated latency (in nanoseconds) in processing", "              requests. Default to zero which completes requests immediately.", "              (Since 2.4)", "", " Since: 2.2", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsNull", fields: Object({"*latency-ns": String("uint64"), "*size": String("int")}), base: Null }) }, Section { description: ["#", " @BlockdevOptionsVVFAT", "", " Driver specific block device options for the vvfat protocol.", "", " @dir:         directory to be exported as FAT image", " @fat-type:    #optional FAT type: 12, 16 or 32", " @floppy:      #optional whether to export a floppy image (true) or", "               partitioned hard disk (false; default)", " @rw:          #optional whether to allow write operations (default: false)", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsVVFAT", fields: Object({"*fat-type": String("int"), "*floppy": String("bool"), "*rw": String("bool"), "dir": String("str")}), base: Null }) }, Section { description: ["#", " @BlockdevOptionsGenericFormat", "", " Driver specific block device options for image format that have no option", " besides their data source.", "", " @file:        reference to or definition of the data source block device", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsGenericFormat", fields: Object({"file": String("BlockdevRef")}), base: Null }) }, Section { description: ["#", " @BlockdevOptionsGenericCOWFormat", "", " Driver specific block device options for image format that have no option", " besides their data source and an optional backing file.", "", " @backing:     #optional reference to or definition of the backing file block", "               device (if missing, taken from the image file content). It is", "               allowed to pass an empty string here in order to disable the", "               default backing file.", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsGenericCOWFormat", fields: Object({"*backing": String("BlockdevRef")}), base: String("BlockdevOptionsGenericFormat") }) }, Section { description: ["#", " @Qcow2OverlapCheckMode", "", " General overlap check modes.", "", " @none:        Do not perform any checks", "", " @constant:    Perform only checks which can be done in constant time and", "               without reading anything from disk", "", " @cached:      Perform only checks which can be done without reading anything", "               from disk", "", " @all:         Perform all available overlap checks", "", " Since: 2.2", "#"], qemu_type: Enum(Enum { name: "Qcow2OverlapCheckMode", fields: Array([String("none"), String("constant"), String("cached"), String("all")]) }) }, Section { description: ["#", " @Qcow2OverlapCheckFlags", "", " Structure of flags for each metadata structure. Setting a field to \"true\"", " makes qemu guard that structure against unintended overwriting. The default", " value is chosen according to the template given.", "", " @template: Specifies a template mode which can be adjusted using the other", "            flags, defaults to \"cached\"", "", " Since: 2.2", "#"], qemu_type: Struct(Struct { name: "Qcow2OverlapCheckFlags", fields: Object({"*active-l1": String("bool"), "*active-l2": String("bool"), "*inactive-l1": String("bool"), "*inactive-l2": String("bool"), "*main-header": String("bool"), "*refcount-block": String("bool"), "*refcount-table": String("bool"), "*snapshot-table": String("bool"), "*template": String("Qcow2OverlapCheckMode")}), base: Null }) }, Section { description: ["#", " @Qcow2OverlapChecks", "", " Specifies which metadata structures should be guarded against unintended", " overwriting.", "", " @flags:   set of flags for separate specification of each metadata structure", "           type", "", " @mode:    named mode which chooses a specific set of flags", "", " Since: 2.2", "#"], qemu_type: Unknown }, Section { description: ["#", " @BlockdevOptionsQcow2", "", " Driver specific block device options for qcow2.", "", " @lazy-refcounts:        #optional whether to enable the lazy refcounts", "                         feature (default is taken from the image file)", "", " @pass-discard-request:  #optional whether discard requests to the qcow2", "                         device should be forwarded to the data source", "", " @pass-discard-snapshot: #optional whether discard requests for the data source", "                         should be issued when a snapshot operation (e.g.", "                         deleting a snapshot) frees clusters in the qcow2 file", "", " @pass-discard-other:    #optional whether discard requests for the data source", "                         should be issued on other occasions where a cluster", "                         gets freed", "", " @overlap-check:         #optional which overlap checks to perform for writes", "                         to the image, defaults to \"cached\" (since 2.2)", "", " @cache-size:            #optional the maximum total size of the L2 table and", "                         refcount block caches in bytes (since 2.2)", "", " @l2-cache-size:         #optional the maximum size of the L2 table cache in", "                         bytes (since 2.2)", "", " @refcount-cache-size:   #optional the maximum size of the refcount block cache", "                         in bytes (since 2.2)", "", " Since: 1.7", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsQcow2", fields: Object({"*cache-size": String("int"), "*l2-cache-size": String("int"), "*lazy-refcounts": String("bool"), "*overlap-check": String("Qcow2OverlapChecks"), "*pass-discard-other": String("bool"), "*pass-discard-request": String("bool"), "*pass-discard-snapshot": String("bool"), "*refcount-cache-size": String("int")}), base: String("BlockdevOptionsGenericCOWFormat") }) }, Section { description: ["#", " @BlockdevOptionsArchipelago", "", " Driver specific block device options for Archipelago.", "", " @volume:              Name of the Archipelago volume image", "", " @mport:               #optional The port number on which mapperd is", "                       listening. This is optional", "                       and if not specified, QEMU will make Archipelago", "                       use the default port (1001).", "", " @vport:               #optional The port number on which vlmcd is", "                       listening. This is optional", "                       and if not specified, QEMU will make Archipelago", "                       use the default port (501).", "", " @segment:             #optional The name of the shared memory segment", "                       Archipelago stack is using. This is optional", "                       and if not specified, QEMU will make Archipelago", "                       use the default value, \"archipelago\".", " Since: 2.2", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsArchipelago", fields: Object({"*mport": String("int"), "*segment": String("str"), "*vport": String("int"), "volume": String("str")}), base: Null }) }, Section { description: ["#", " @BlkdebugEvent", "", " Trigger events supported by blkdebug.", "#"], qemu_type: Enum(Enum { name: "BlkdebugEvent", fields: Array([String("l1_update"), String("l1_grow.alloc_table"), String("l1_grow.write_table"), String("l1_grow.activate_table"), String("l2_load"), String("l2_update"), String("l2_update_compressed"), String("l2_alloc.cow_read"), String("l2_alloc.write"), String("read_aio"), String("read_backing_aio"), String("read_compressed"), String("write_aio"), String("write_compressed"), String("vmstate_load"), String("vmstate_save"), String("cow_read"), String("cow_write"), String("reftable_load"), String("reftable_grow"), String("reftable_update"), String("refblock_load"), String("refblock_update"), String("refblock_update_part"), String("refblock_alloc"), String("refblock_alloc.hookup"), String("refblock_alloc.write"), String("refblock_alloc.write_blocks"), String("refblock_alloc.write_table"), String("refblock_alloc.switch_table"), String("cluster_alloc"), String("cluster_alloc_bytes"), String("cluster_free"), String("flush_to_os"), String("flush_to_disk"), String("pwritev_rmw.head"), String("pwritev_rmw.after_head"), String("pwritev_rmw.tail"), String("pwritev_rmw.after_tail"), String("pwritev"), String("pwritev_zero"), String("pwritev_done"), String("empty_image_prepare")]) }) }, Section { description: ["#", " @BlkdebugInjectErrorOptions", "", " Describes a single error injection for blkdebug.", "", " @event:       trigger event", "", " @state:       #optional the state identifier blkdebug needs to be in to", "               actually trigger the event; defaults to \"any\"", "", " @errno:       #optional error identifier (errno) to be returned; defaults to", "               EIO", "", " @sector:      #optional specifies the sector index which has to be affected", "               in order to actually trigger the event; defaults to \"any", "               sector\"", "", " @once:        #optional disables further events after this one has been", "               triggered; defaults to false", "", " @immediately: #optional fail immediately; defaults to false", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "BlkdebugInjectErrorOptions", fields: Object({"*errno": String("int"), "*immediately": String("bool"), "*once": String("bool"), "*sector": String("int"), "*state": String("int"), "event": String("BlkdebugEvent")}), base: Null }) }, Section { description: ["#", " @BlkdebugSetStateOptions", "", " Describes a single state-change event for blkdebug.", "", " @event:       trigger event", "", " @state:       #optional the current state identifier blkdebug needs to be in;", "               defaults to \"any\"", "", " @new_state:   the state identifier blkdebug is supposed to assume if", "               this event is triggered", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "BlkdebugSetStateOptions", fields: Object({"*state": String("int"), "event": String("BlkdebugEvent"), "new_state": String("int")}), base: Null }) }, Section { description: ["#", " @BlockdevOptionsBlkdebug", "", " Driver specific block device options for blkdebug.", "", " @image:           underlying raw block device (or image file)", "", " @config:          #optional filename of the configuration file", "", " @align:           #optional required alignment for requests in bytes", "", " @inject-error:    #optional array of error injection descriptions", "", " @set-state:       #optional array of state-change descriptions", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsBlkdebug", fields: Object({"*align": String("int"), "*config": String("str"), "*inject-error": Array([String("BlkdebugInjectErrorOptions")]), "*set-state": Array([String("BlkdebugSetStateOptions")]), "image": String("BlockdevRef")}), base: Null }) }, Section { description: ["#", " @BlockdevOptionsBlkverify", "", " Driver specific block device options for blkverify.", "", " @test:    block device to be tested", "", " @raw:     raw image used for verification", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsBlkverify", fields: Object({"raw": String("BlockdevRef"), "test": String("BlockdevRef")}), base: Null }) }, Section { description: ["#", " @QuorumReadPattern", "", " An enumeration of quorum read patterns.", "", " @quorum: read all the children and do a quorum vote on reads", "", " @fifo: read only from the first child that has not failed", "", " Since: 2.2", "#"], qemu_type: Enum(Enum { name: "QuorumReadPattern", fields: Array([String("quorum"), String("fifo")]) }) }, Section { description: ["#", " @BlockdevOptionsQuorum", "", " Driver specific block device options for Quorum", "", " @blkverify:      #optional true if the driver must print content mismatch", "                  set to false by default", "", " @children:       the children block devices to use", "", " @vote-threshold: the vote limit under which a read will fail", "", " @rewrite-corrupted: #optional rewrite corrupted data when quorum is reached", "                     (Since 2.1)", "", " @read-pattern: #optional choose read pattern and set to quorum by default", "                (Since 2.2)", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "BlockdevOptionsQuorum", fields: Object({"*blkverify": String("bool"), "*read-pattern": String("QuorumReadPattern"), "*rewrite-corrupted": String("bool"), "children": Array([String("BlockdevRef")]), "vote-threshold": String("int")}), base: Null }) }, Section { description: ["#", " @BlockdevOptions", "", " Options for creating a block device.", "", " Since: 1.7", "#"], qemu_type: Union(Union { name: "BlockdevOptions", discriminator: String("driver"), data: Object({"archipelago": String("BlockdevOptionsArchipelago"), "blkdebug": String("BlockdevOptionsBlkdebug"), "blkverify": String("BlockdevOptionsBlkverify"), "bochs": String("BlockdevOptionsGenericFormat"), "cloop": String("BlockdevOptionsGenericFormat"), "dmg": String("BlockdevOptionsGenericFormat"), "file": String("BlockdevOptionsFile"), "ftp": String("BlockdevOptionsFile"), "ftps": String("BlockdevOptionsFile"), "host_cdrom": String("BlockdevOptionsFile"), "host_device": String("BlockdevOptionsFile"), "host_floppy": String("BlockdevOptionsFile"), "http": String("BlockdevOptionsFile"), "https": String("BlockdevOptionsFile"), "null-aio": String("BlockdevOptionsNull"), "null-co": String("BlockdevOptionsNull"), "parallels": String("BlockdevOptionsGenericFormat"), "qcow": String("BlockdevOptionsGenericCOWFormat"), "qcow2": String("BlockdevOptionsQcow2"), "qed": String("BlockdevOptionsGenericCOWFormat"), "quorum": String("BlockdevOptionsQuorum"), "raw": String("BlockdevOptionsGenericFormat"), "tftp": String("BlockdevOptionsFile"), "vdi": String("BlockdevOptionsGenericFormat"), "vhdx": String("BlockdevOptionsGenericFormat"), "vmdk": String("BlockdevOptionsGenericCOWFormat"), "vpc": String("BlockdevOptionsGenericFormat"), "vvfat": String("BlockdevOptionsVVFAT")}) }) }, Section { description: ["#", " @BlockdevRef", "", " Reference to a block device.", "", " @definition:      defines a new block device inline", " @reference:       references the ID of an existing block device. An", "                   empty string means that no block device should be", "                   referenced.", "", " Since: 1.7", "#"], qemu_type: Unknown }, Section { description: ["#", " @blockdev-add:", "", " Creates a new block device.", "", " This command is still a work in progress.  It doesn\"t support all", " block drivers, it lacks a matching blockdev-del, and more.  Stay", " away from it unless you want to help with its development.", "", " @options: block device options for the new device", "", " Since: 1.7", "#"], qemu_type: Command(Command { name: "blockdev-add", fields: Object({"options": String("BlockdevOptions")}), gen: Null, returns: Null }) }, Section { description: ["#", " @BlockErrorAction", "", " An enumeration of action that has been taken when a DISK I/O occurs", "", " @ignore: error has been ignored", "", " @report: error has been reported to the device", "", " @stop: error caused VM to be stopped", "", " Since: 2.1", "#"], qemu_type: Enum(Enum { name: "BlockErrorAction", fields: Array([String("ignore"), String("report"), String("stop")]) }) }, Section { description: ["#", " @BLOCK_IMAGE_CORRUPTED", "", " Emitted when a corruption has been detected in a disk image", "", " @device: device name. This is always present for compatibility", "          reasons, but it can be empty (\"\") if the image does not", "          have a device name associated.", "", " @node-name: #optional node name (Since: 2.4)", "", " @msg: informative message for human consumption, such as the kind of", "       corruption being detected. It should not be parsed by machine as it is", "       not guaranteed to be stable", "", " @offset: #optional, if the corruption resulted from an image access, this is", "          the host\"s access offset into the image", "", " @size: #optional, if the corruption resulted from an image access, this is", "        the access size", "", " fatal: if set, the image is marked corrupt and therefore unusable after this", "        event and must be repaired (Since 2.2; before, every", "        BLOCK_IMAGE_CORRUPTED event was fatal)", "", " Since: 1.7", "#"], qemu_type: Event(Event { name: "BLOCK_IMAGE_CORRUPTED", data: Object({"*node-name": String("str"), "*offset": String("int"), "*size": String("int"), "device": String("str"), "fatal": String("bool"), "msg": String("str")}) }) }, Section { description: ["#", " @BLOCK_IO_ERROR", "", " Emitted when a disk I/O error occurs", "", " @device: device name", "", " @operation: I/O operation", "", " @action: action that has been taken", "", " @nospace: #optional true if I/O error was caused due to a no-space", "           condition. This key is only present if query-block\"s", "           io-status is present, please see query-block documentation", "           for more information (since: 2.2)", "", " @reason: human readable string describing the error cause.", "          (This field is a debugging aid for humans, it should not", "           be parsed by applications) (since: 2.2)", "", " Note: If action is \"stop\", a STOP event will eventually follow the", " BLOCK_IO_ERROR event", "", " Since: 0.13.0", "#"], qemu_type: Event(Event { name: "BLOCK_IO_ERROR", data: Object({"*nospace": String("bool"), "action": String("BlockErrorAction"), "device": String("str"), "operation": String("IoOperationType"), "reason": String("str")}) }) }, Section { description: ["#", " @BLOCK_JOB_COMPLETED", "", " Emitted when a block job has completed", "", " @type: job type", "", " @device: device name", "", " @len: maximum progress value", "", " @offset: current progress value. On success this is equal to len.", "          On failure this is less than len", "", " @speed: rate limit, bytes per second", "", " @error: #optional, error message. Only present on failure. This field", "         contains a human-readable error message. There are no semantics", "         other than that streaming has failed and clients should not try to", "         interpret the error string", "", " Since: 1.1", "#"], qemu_type: Event(Event { name: "BLOCK_JOB_COMPLETED", data: Object({"*error": String("str"), "device": String("str"), "len": String("int"), "offset": String("int"), "speed": String("int"), "type": String("BlockJobType")}) }) }, Section { description: ["#", " @BLOCK_JOB_CANCELLED", "", " Emitted when a block job has been cancelled", "", " @type: job type", "", " @device: device name", "", " @len: maximum progress value", "", " @offset: current progress value. On success this is equal to len.", "          On failure this is less than len", "", " @speed: rate limit, bytes per second", "", " Since: 1.1", "#"], qemu_type: Event(Event { name: "BLOCK_JOB_CANCELLED", data: Object({"device": String("str"), "len": String("int"), "offset": String("int"), "speed": String("int"), "type": String("BlockJobType")}) }) }, Section { description: ["#", " @BLOCK_JOB_ERROR", "", " Emitted when a block job encounters an error", "", " @device: device name", "", " @operation: I/O operation", "", " @action: action that has been taken", "", " Since: 1.3", "#"], qemu_type: Event(Event { name: "BLOCK_JOB_ERROR", data: Object({"action": String("BlockErrorAction"), "device": String("str"), "operation": String("IoOperationType")}) }) }, Section { description: ["#", " @BLOCK_JOB_READY", "", " Emitted when a block job is ready to complete", "", " @type: job type", "", " @device: device name", "", " @len: maximum progress value", "", " @offset: current progress value. On success this is equal to len.", "          On failure this is less than len", "", " @speed: rate limit, bytes per second", "", " Note: The \"ready to complete\" status is always reset by a @BLOCK_JOB_ERROR", " event", "", " Since: 1.3", "#"], qemu_type: Event(Event { name: "BLOCK_JOB_READY", data: Object({"device": String("str"), "len": String("int"), "offset": String("int"), "speed": String("int"), "type": String("BlockJobType")}) }) }, Section { description: [" @PreallocMode", "", " Preallocation mode of QEMU image file", "", " @off: no preallocation", " @metadata: preallocate only for metadata", " @falloc: like @full preallocation but allocate disk space by", "          posix_fallocate() rather than writing zeros.", " @full: preallocate all data by writing zeros to device to ensure disk", "        space is really available. @full preallocation also sets up", "        metadata correctly.", "", " Since 2.2", "#"], qemu_type: Enum(Enum { name: "PreallocMode", fields: Array([String("off"), String("metadata"), String("falloc"), String("full")]) }) }, Section { description: ["#", " @BLOCK_WRITE_THRESHOLD", "", " Emitted when writes on block device reaches or exceeds the", " configured write threshold. For thin-provisioned devices, this", " means the device should be extended to avoid pausing for", " disk exhaustion.", " The event is one shot. Once triggered, it needs to be", " re-registered with another block-set-threshold command.", "", " @node-name: graph node name on which the threshold was exceeded.", "", " @amount-exceeded: amount of data which exceeded the threshold, in bytes.", "", " @write-threshold: last configured threshold, in bytes.", "", " Since: 2.3", "#"], qemu_type: Event(Event { name: "BLOCK_WRITE_THRESHOLD", data: Object({"amount-exceeded": String("uint64"), "node-name": String("str"), "write-threshold": String("uint64")}) }) }, Section { description: ["#", " @block-set-write-threshold", "", " Change the write threshold for a block drive. An event will be delivered", " if a write to this block drive crosses the configured threshold.", " This is useful to transparently resize thin-provisioned drives without", " the guest OS noticing.", "", " @node-name: graph node name on which the threshold must be set.", "", " @write-threshold: configured threshold for the block device, bytes.", "                   Use 0 to disable the threshold.", "", " Since: 2.3", "#"], qemu_type: Command(Command { name: "block-set-write-threshold", fields: Object({"node-name": String("str"), "write-threshold": String("uint64")}), gen: Null, returns: Null }) }, Section { description: [" -*- Mode: Python -*-", "", " QAPI common definitions"], qemu_type: Enum(Enum { name: "ErrorClass", fields: Array([String("GenericError"), String("CommandNotFound"), String("DeviceEncrypted"), String("DeviceNotActive"), String("DeviceNotFound"), String("KVMMissingCap")]) }) }, Section { description: ["#", " @VersionTriple", "", " A three-part version number.", "", " @qemu.major:  The major version number.", "", " @qemu.minor:  The minor version number.", "", " @qemu.micro:  The micro version number.", "", " Since: 2.4", "#"], qemu_type: Struct(Struct { name: "VersionTriple", fields: Object({"major": String("int"), "micro": String("int"), "minor": String("int")}), base: Null }) }, Section { description: ["#", " @VersionInfo:", "", " A description of QEMU\"s version.", "", " @qemu:        The version of QEMU.  By current convention, a micro", "               version of 50 signifies a development branch.  A micro version", "               greater than or equal to 90 signifies a release candidate for", "               the next minor version.  A micro version of less than 50", "               signifies a stable release.", "", " @package:     QEMU will always set this field to an empty string.  Downstream", "               versions of QEMU should set this to a non-empty string.  The", "               exact format depends on the downstream however it highly", "               recommended that a unique name is used.", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "VersionInfo", fields: Object({"package": String("str"), "qemu": String("VersionTriple")}), base: Null }) }, Section { description: ["#", " @query-version:", "", " Returns the current version of QEMU.", "", " Returns:  A @VersionInfo object describing the current version of QEMU.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-version", fields: Null, gen: Null, returns: String("VersionInfo") }) }, Section { description: ["#", " @CommandInfo:", "", " Information about a QMP command", "", " @name: The command name", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "CommandInfo", fields: Object({"name": String("str")}), base: Null }) }, Section { description: ["#", " @query-commands:", "", " Return a list of supported QMP commands by this server", "", " Returns: A list of @CommandInfo for all supported commands", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-commands", fields: Null, gen: Null, returns: Array([String("CommandInfo")]) }) }, Section { description: ["#", " @OnOffAuto", "", " An enumeration of three options: on, off, and auto", "", " @auto: QEMU selects the value between on and off", "", " @on: Enabled", "", " @off: Disabled", "", " Since: 2.2", "#"], qemu_type: Enum(Enum { name: "OnOffAuto", fields: Array([String("auto"), String("on"), String("off")]) }) }, Section { description: [" -*- mode: python -*-", "", " Copyright (C) 2011-2014 Lluís Vilanova <vilanova@ac.upc.edu>", "", " This work is licensed under the terms of the GNU GPL, version 2 or later.", " See the COPYING file in the top-level directory."], qemu_type: Enum(Enum { name: "TraceEventState", fields: Array([String("unavailable"), String("disabled"), String("enabled")]) }) }, Section { description: ["#", " @TraceEventInfo:", "", " Information of a tracing event.", "", " @name: Event name.", " @state: Tracing state.", "", " Since 2.2", "#"], qemu_type: Struct(Struct { name: "TraceEventInfo", fields: Object({"name": String("str"), "state": String("TraceEventState")}), base: Null }) }, Section { description: ["#", " @trace-event-get-state:", "", " Query the state of events.", "", " @name: Event name pattern (case-sensitive glob).", "", " Returns: a list of @TraceEventInfo for the matching events", "", " Since 2.2", "#"], qemu_type: Command(Command { name: "trace-event-get-state", fields: Object({"name": String("str")}), gen: Null, returns: Array([String("TraceEventInfo")]) }) }, Section { description: ["#", " @trace-event-set-state:", "", " Set the dynamic tracing state of events.", "", " @name: Event name pattern (case-sensitive glob).", " @enable: Whether to enable tracing.", " @ignore-unavailable: #optional Do not match unavailable events with @name.", "", " Since 2.2", "#"], qemu_type: Command(Command { name: "trace-event-set-state", fields: Object({"*ignore-unavailable": String("bool"), "enable": String("bool"), "name": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @SHUTDOWN", "", " Emitted when the virtual machine has shut down, indicating that qemu is", " about to exit.", "", " Note: If the command-line option \"-no-shutdown\" has been specified, qemu will", " not exit, and a STOP event will eventually follow the SHUTDOWN event", "", " Since: 0.12.0", "#"], qemu_type: Event(Event { name: "SHUTDOWN", data: Null }) }, Section { description: ["#", " @POWERDOWN", "", " Emitted when the virtual machine is powered down through the power control", " system, such as via ACPI.", "", " Since: 0.12.0", "#"], qemu_type: Event(Event { name: "POWERDOWN", data: Null }) }, Section { description: ["#", " @RESET", "", " Emitted when the virtual machine is reset", "", " Since: 0.12.0", "#"], qemu_type: Event(Event { name: "RESET", data: Null }) }, Section { description: ["#", " @STOP", "", " Emitted when the virtual machine is stopped", "", " Since: 0.12.0", "#"], qemu_type: Event(Event { name: "STOP", data: Null }) }, Section { description: ["#", " @RESUME", "", " Emitted when the virtual machine resumes execution", "", " Since: 0.12.0", "#"], qemu_type: Event(Event { name: "RESUME", data: Null }) }, Section { description: ["#", " @SUSPEND", "", " Emitted when guest enters a hardware suspension state, for example, S3 state,", " which is sometimes called standby state", "", " Since: 1.1", "#"], qemu_type: Event(Event { name: "SUSPEND", data: Null }) }, Section { description: ["#", " @SUSPEND_DISK", "", " Emitted when guest enters a hardware suspension state with data saved on", " disk, for example, S4 state, which is sometimes called hibernate state", "", " Note: QEMU shuts down (similar to event @SHUTDOWN) when entering this state", "", " Since: 1.2", "#"], qemu_type: Event(Event { name: "SUSPEND_DISK", data: Null }) }, Section { description: ["#", " @WAKEUP", "", " Emitted when the guest has woken up from suspend state and is running", "", " Since: 1.1", "#"], qemu_type: Event(Event { name: "WAKEUP", data: Null }) }, Section { description: ["#", " @RTC_CHANGE", "", " Emitted when the guest changes the RTC time.", "", " @offset: offset between base RTC clock (as specified by -rtc base), and", "          new RTC clock value", "", " Since: 0.13.0", "#"], qemu_type: Event(Event { name: "RTC_CHANGE", data: Object({"offset": String("int")}) }) }, Section { description: ["#", " @WATCHDOG", "", " Emitted when the watchdog device\"s timer is expired", "", " @action: action that has been taken", "", " Note: If action is \"reset\", \"shutdown\", or \"pause\" the WATCHDOG event is", " followed respectively by the RESET, SHUTDOWN, or STOP events", "", " Since: 0.13.0", "#"], qemu_type: Event(Event { name: "WATCHDOG", data: Object({"action": String("WatchdogExpirationAction")}) }) }, Section { description: ["#", " @DEVICE_DELETED", "", " Emitted whenever the device removal completion is acknowledged by the guest.", " At this point, it\"s safe to reuse the specified device ID. Device removal can", " be initiated by the guest or by HMP/QMP commands.", "", " @device: #optional, device name", "", " @path: device path", "", " Since: 1.5", "#"], qemu_type: Event(Event { name: "DEVICE_DELETED", data: Object({"*device": String("str"), "path": String("str")}) }) }, Section { description: ["#", " @NIC_RX_FILTER_CHANGED", "", " Emitted once until the \"query-rx-filter\" command is executed, the first event", " will always be emitted", "", " @name: #optional, net client name", "", " @path: device path", "", " Since: 1.6", "#"], qemu_type: Event(Event { name: "NIC_RX_FILTER_CHANGED", data: Object({"*name": String("str"), "path": String("str")}) }) }, Section { description: ["#", " @VNC_CONNECTED", "", " Emitted when a VNC client establishes a connection", "", " @server: server information", "", " @client: client information", "", " Note: This event is emitted before any authentication takes place, thus", " the authentication ID is not provided", "", " Since: 0.13.0", "#"], qemu_type: Event(Event { name: "VNC_CONNECTED", data: Object({"client": String("VncBasicInfo"), "server": String("VncServerInfo")}) }) }, Section { description: ["#", " @VNC_INITIALIZED", "", " Emitted after authentication takes place (if any) and the VNC session is", " made active", "", " @server: server information", "", " @client: client information", "", " Since: 0.13.0", "#"], qemu_type: Event(Event { name: "VNC_INITIALIZED", data: Object({"client": String("VncClientInfo"), "server": String("VncServerInfo")}) }) }, Section { description: ["#", " @VNC_DISCONNECTED", "", " Emitted when the connection is closed", "", " @server: server information", "", " @client: client information", "", " Since: 0.13.0", "#"], qemu_type: Event(Event { name: "VNC_DISCONNECTED", data: Object({"client": String("VncClientInfo"), "server": String("VncServerInfo")}) }) }, Section { description: ["#", " @SPICE_CONNECTED", "", " Emitted when a SPICE client establishes a connection", "", " @server: server information", "", " @client: client information", "", " Since: 0.14.0", "#"], qemu_type: Event(Event { name: "SPICE_CONNECTED", data: Object({"client": String("SpiceBasicInfo"), "server": String("SpiceBasicInfo")}) }) }, Section { description: ["#", " @SPICE_INITIALIZED", "", " Emitted after initial handshake and authentication takes place (if any)", " and the SPICE channel is up and running", "", " @server: server information", "", " @client: client information", "", " Since: 0.14.0", "#"], qemu_type: Event(Event { name: "SPICE_INITIALIZED", data: Object({"client": String("SpiceChannel"), "server": String("SpiceServerInfo")}) }) }, Section { description: ["#", " @SPICE_DISCONNECTED", "", " Emitted when the SPICE connection is closed", "", " @server: server information", "", " @client: client information", "", " Since: 0.14.0", "#"], qemu_type: Event(Event { name: "SPICE_DISCONNECTED", data: Object({"client": String("SpiceBasicInfo"), "server": String("SpiceBasicInfo")}) }) }, Section { description: ["#", " @SPICE_MIGRATE_COMPLETED", "", " Emitted when SPICE migration has completed", "", " Since: 1.3", "#"], qemu_type: Event(Event { name: "SPICE_MIGRATE_COMPLETED", data: Null }) }, Section { description: ["#", " @ACPI_DEVICE_OST", "", " Emitted when guest executes ACPI _OST method.", "", " Since: 2.1", "", " @info: ACPIOSTInfo type as described in qapi-schema.json", "#"], qemu_type: Event(Event { name: "ACPI_DEVICE_OST", data: Object({"info": String("ACPIOSTInfo")}) }) }, Section { description: ["#", " @BALLOON_CHANGE", "", " Emitted when the guest changes the actual BALLOON level. This value is", " equivalent to the @actual field return by the \"query-balloon\" command", "", " @actual: actual level of the guest memory balloon in bytes", "", " Since: 1.2", "#"], qemu_type: Event(Event { name: "BALLOON_CHANGE", data: Object({"actual": String("int")}) }) }, Section { description: ["#", " @GUEST_PANICKED", "", " Emitted when guest OS panic is detected", "", " @action: action that has been taken, currently always \"pause\"", "", " Since: 1.5", "#"], qemu_type: Event(Event { name: "GUEST_PANICKED", data: Object({"action": String("GuestPanicAction")}) }) }, Section { description: ["#", " @QUORUM_FAILURE", "", " Emitted by the Quorum block driver if it fails to establish a quorum", "", " @reference: device name if defined else node name", "", " @sector-num: number of the first sector of the failed read operation", "", " @sectors-count: failed read operation sector count", "", " Since: 2.0", "#"], qemu_type: Event(Event { name: "QUORUM_FAILURE", data: Object({"reference": String("str"), "sector-num": String("int"), "sectors-count": String("int")}) }) }, Section { description: ["#", " @QUORUM_REPORT_BAD", "", " Emitted to report a corruption of a Quorum file", "", " @error: #optional, error message. Only present on failure. This field", "         contains a human-readable error message. There are no semantics other", "         than that the block layer reported an error and clients should not", "         try to interpret the error string.", "", " @node-name: the graph node name of the block driver state", "", " @sector-num: number of the first sector of the failed read operation", "", " @sectors-count: failed read operation sector count", "", " Since: 2.0", "#"], qemu_type: Event(Event { name: "QUORUM_REPORT_BAD", data: Object({"*error": String("str"), "node-name": String("str"), "sector-num": String("int"), "sectors-count": String("int")}) }) }, Section { description: ["#", " @VSERPORT_CHANGE", "", " Emitted when the guest opens or closes a virtio-serial port.", "", " @id: device identifier of the virtio-serial port", "", " @open: true if the guest has opened the virtio-serial port", "", " Since: 2.1", "#"], qemu_type: Event(Event { name: "VSERPORT_CHANGE", data: Object({"id": String("str"), "open": String("bool")}) }) }, Section { description: ["#", " @MEM_UNPLUG_ERROR", "", " Emitted when memory hot unplug error occurs.", "", " @device: device name", "", " @msg: Informative message", "", " Since: 2.4", "#"], qemu_type: Event(Event { name: "MEM_UNPLUG_ERROR", data: Object({"device": String("str"), "msg": String("str")}) }) }, Section { description: [" -*- Mode: Python -*-", "", " QAPI Schema"], qemu_type: Include { name: "" } }, Section { description: [" QAPI block definitions"], qemu_type: Include { name: "" } }, Section { description: [" QAPI event definitions"], qemu_type: Include { name: "" } }, Section { description: [" Tracing commands"], qemu_type: Include { name: "" } }, Section { description: ["#", " LostTickPolicy:", "", " Policy for handling lost ticks in timer devices.", "", " @discard: throw away the missed tick(s) and continue with future injection", "           normally.  Guest time may be delayed, unless the OS has explicit", "           handling of lost ticks", "", " @delay: continue to deliver ticks at the normal rate.  Guest time will be", "         delayed due to the late tick", "", " @merge: merge the missed tick(s) into one tick and inject.  Guest time", "         may be delayed, depending on how the OS reacts to the merging", "         of ticks", "", " @slew: deliver ticks at a higher rate to catch up with the missed tick. The", "        guest time should not be delayed once catchup is complete.", "", " Since: 2.0", "#"], qemu_type: Enum(Enum { name: "LostTickPolicy", fields: Array([String("discard"), String("delay"), String("merge"), String("slew")]) }) }, Section { description: [" @add_client", "", " Allow client connections for VNC, Spice and socket based", " character devices to be passed in to QEMU via SCM_RIGHTS.", "", " @protocol: protocol name. Valid names are \"vnc\", \"spice\" or the", "            name of a character device (eg. from -chardev id=XXXX)", "", " @fdname: file descriptor name previously passed via \"getfd\" command", "", " @skipauth: #optional whether to skip authentication. Only applies", "            to \"vnc\" and \"spice\" protocols", "", " @tls: #optional whether to perform TLS. Only applies to the \"spice\"", "       protocol", "", " Returns: nothing on success.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "add_client", fields: Object({"*skipauth": String("bool"), "*tls": String("bool"), "fdname": String("str"), "protocol": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @NameInfo:", "", " Guest name information.", "", " @name: #optional The name of the guest", "", " Since 0.14.0", "#"], qemu_type: Struct(Struct { name: "NameInfo", fields: Object({"*name": String("str")}), base: Null }) }, Section { description: ["#", " @query-name:", "", " Return the name information of a guest.", "", " Returns: @NameInfo of the guest", "", " Since 0.14.0", "#"], qemu_type: Command(Command { name: "query-name", fields: Null, gen: Null, returns: String("NameInfo") }) }, Section { description: ["#", " @KvmInfo:", "", " Information about support for KVM acceleration", "", " @enabled: true if KVM acceleration is active", "", " @present: true if KVM acceleration is built into this executable", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "KvmInfo", fields: Object({"enabled": String("bool"), "present": String("bool")}), base: Null }) }, Section { description: ["#", " @query-kvm:", "", " Returns information about KVM acceleration", "", " Returns: @KvmInfo", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-kvm", fields: Null, gen: Null, returns: String("KvmInfo") }) }, Section { description: ["#", " @RunState", "", " An enumeration of VM run states.", "", " @debug: QEMU is running on a debugger", "", " @finish-migrate: guest is paused to finish the migration process", "", " @inmigrate: guest is paused waiting for an incoming migration.  Note", " that this state does not tell whether the machine will start at the", " end of the migration.  This depends on the command-line -S option and", " any invocation of \"stop\" or \"cont\" that has happened since QEMU was", " started.", "", " @internal-error: An internal error that prevents further guest execution", " has occurred", "", " @io-error: the last IOP has failed and the device is configured to pause", " on I/O errors", "", " @paused: guest has been paused via the \"stop\" command", "", " @postmigrate: guest is paused following a successful \"migrate\"", "", " @prelaunch: QEMU was started with -S and guest has not started", "", " @restore-vm: guest is paused to restore VM state", "", " @running: guest is actively running", "", " @save-vm: guest is paused to save the VM state", "", " @shutdown: guest is shut down (and -no-shutdown is in use)", "", " @suspended: guest is suspended (ACPI S3)", "", " @watchdog: the watchdog action is configured to pause and has been triggered", "", " @guest-panicked: guest has been panicked as a result of guest OS panic", "#"], qemu_type: Enum(Enum { name: "RunState", fields: Array([String("debug"), String("inmigrate"), String("internal-error"), String("io-error"), String("paused"), String("postmigrate"), String("prelaunch"), String("finish-migrate"), String("restore-vm"), String("running"), String("save-vm"), String("shutdown"), String("suspended"), String("watchdog"), String("guest-panicked")]) }) }, Section { description: ["#", " @StatusInfo:", "", " Information about VCPU run state", "", " @running: true if all VCPUs are runnable, false if not runnable", "", " @singlestep: true if VCPUs are in single-step mode", "", " @status: the virtual machine @RunState", "", " Since:  0.14.0", "", " Notes: @singlestep is enabled through the GDB stub", "#"], qemu_type: Struct(Struct { name: "StatusInfo", fields: Object({"running": String("bool"), "singlestep": String("bool"), "status": String("RunState")}), base: Null }) }, Section { description: ["#", " @query-status:", "", " Query the run status of all VCPUs", "", " Returns: @StatusInfo reflecting all VCPUs", "", " Since:  0.14.0", "#"], qemu_type: Command(Command { name: "query-status", fields: Null, gen: Null, returns: String("StatusInfo") }) }, Section { description: ["#", " @UuidInfo:", "", " Guest UUID information.", "", " @UUID: the UUID of the guest", "", " Since: 0.14.0", "", " Notes: If no UUID was specified for the guest, a null UUID is returned.", "#"], qemu_type: Struct(Struct { name: "UuidInfo", fields: Object({"UUID": String("str")}), base: Null }) }, Section { description: ["#", " @query-uuid:", "", " Query the guest UUID information.", "", " Returns: The @UuidInfo for the guest", "", " Since 0.14.0", "#"], qemu_type: Command(Command { name: "query-uuid", fields: Null, gen: Null, returns: String("UuidInfo") }) }, Section { description: ["#", " @ChardevInfo:", "", " Information about a character device.", "", " @label: the label of the character device", "", " @filename: the filename of the character device", "", " @frontend-open: shows whether the frontend device attached to this backend", "                 (eg. with the chardev=... option) is in open or closed state", "                 (since 2.1)", "", " Notes: @filename is encoded using the QEMU command line character device", "        encoding.  See the QEMU man page for details.", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "ChardevInfo", fields: Object({"filename": String("str"), "frontend-open": String("bool"), "label": String("str")}), base: Null }) }, Section { description: ["#", " @query-chardev:", "", " Returns information about current character devices.", "", " Returns: a list of @ChardevInfo", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-chardev", fields: Null, gen: Null, returns: Array([String("ChardevInfo")]) }) }, Section { description: ["#", " @ChardevBackendInfo:", "", " Information about a character device backend", "", " @name: The backend name", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "ChardevBackendInfo", fields: Object({"name": String("str")}), base: Null }) }, Section { description: ["#", " @query-chardev-backends:", "", " Returns information about character device backends.", "", " Returns: a list of @ChardevBackendInfo", "", " Since: 2.0", "#"], qemu_type: Command(Command { name: "query-chardev-backends", fields: Null, gen: Null, returns: Array([String("ChardevBackendInfo")]) }) }, Section { description: ["#", " @DataFormat:", "", " An enumeration of data format.", "", " @utf8: Data is a UTF-8 string (RFC 3629)", "", " @base64: Data is Base64 encoded binary (RFC 3548)", "", " Since: 1.4", "#"], qemu_type: Enum(Enum { name: "DataFormat", fields: Array([String("utf8"), String("base64")]) }) }, Section { description: ["#", " @ringbuf-write:", "", " Write to a ring buffer character device.", "", " @device: the ring buffer character device name", "", " @data: data to write", "", " @format: #optional data encoding (default \"utf8\").", "          - base64: data must be base64 encoded text.  Its binary", "            decoding gets written.", "            Bug: invalid base64 is currently not rejected.", "            Whitespace *is* invalid.", "          - utf8: data\"s UTF-8 encoding is written", "          - data itself is always Unicode regardless of format, like", "            any other string.", "", " Returns: Nothing on success", "", " Since: 1.4", "#"], qemu_type: Command(Command { name: "ringbuf-write", fields: Object({"*format": String("DataFormat"), "data": String("str"), "device": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @ringbuf-read:", "", " Read from a ring buffer character device.", "", " @device: the ring buffer character device name", "", " @size: how many bytes to read at most", "", " @format: #optional data encoding (default \"utf8\").", "          - base64: the data read is returned in base64 encoding.", "          - utf8: the data read is interpreted as UTF-8.", "            Bug: can screw up when the buffer contains invalid UTF-8", "            sequences, NUL characters, after the ring buffer lost", "            data, and when reading stops because the size limit is", "            reached.", "          - The return value is always Unicode regardless of format,", "            like any other string.", "", " Returns: data read from the device", "", " Since: 1.4", "#"], qemu_type: Command(Command { name: "ringbuf-read", fields: Object({"*format": String("DataFormat"), "device": String("str"), "size": String("int")}), gen: Null, returns: String("str") }) }, Section { description: ["#", " @EventInfo:", "", " Information about a QMP event", "", " @name: The event name", "", " Since: 1.2.0", "#"], qemu_type: Struct(Struct { name: "EventInfo", fields: Object({"name": String("str")}), base: Null }) }, Section { description: ["#", " @query-events:", "", " Return a list of supported QMP events by this server", "", " Returns: A list of @EventInfo for all supported events", "", " Since: 1.2.0", "#"], qemu_type: Command(Command { name: "query-events", fields: Null, gen: Null, returns: Array([String("EventInfo")]) }) }, Section { description: ["#", " @MigrationStats", "", " Detailed migration status.", "", " @transferred: amount of bytes already transferred to the target VM", "", " @remaining: amount of bytes remaining to be transferred to the target VM", "", " @total: total amount of bytes involved in the migration process", "", " @duplicate: number of duplicate (zero) pages (since 1.2)", "", " @skipped: number of skipped zero pages (since 1.5)", "", " @normal : number of normal pages (since 1.2)", "", " @normal-bytes: number of normal bytes sent (since 1.2)", "", " @dirty-pages-rate: number of pages dirtied by second by the", "        guest (since 1.3)", "", " @mbps: throughput in megabits/sec. (since 1.6)", "", " @dirty-sync-count: number of times that dirty ram was synchronized (since 2.1)", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "MigrationStats", fields: Object({"dirty-pages-rate": String("int"), "dirty-sync-count": String("int"), "duplicate": String("int"), "mbps": String("number"), "normal": String("int"), "normal-bytes": String("int"), "remaining": String("int"), "skipped": String("int"), "total": String("int"), "transferred": String("int")}), base: Null }) }, Section { description: ["#", " @XBZRLECacheStats", "", " Detailed XBZRLE migration cache statistics", "", " @cache-size: XBZRLE cache size", "", " @bytes: amount of bytes already transferred to the target VM", "", " @pages: amount of pages transferred to the target VM", "", " @cache-miss: number of cache miss", "", " @cache-miss-rate: rate of cache miss (since 2.1)", "", " @overflow: number of overflows", "", " Since: 1.2", "#"], qemu_type: Struct(Struct { name: "XBZRLECacheStats", fields: Object({"bytes": String("int"), "cache-miss": String("int"), "cache-miss-rate": String("number"), "cache-size": String("int"), "overflow": String("int"), "pages": String("int")}), base: Null }) }, Section { description: [" @MigrationStatus:", "", " An enumeration of migration status.", "", " @none: no migration has ever happened.", "", " @setup: migration process has been initiated.", "", " @cancelling: in the process of cancelling migration.", "", " @cancelled: cancelling migration is finished.", "", " @active: in the process of doing migration.", "", " @completed: migration is finished.", "", " @failed: some error occurred during migration process.", "", " Since: 2.3", "", "#"], qemu_type: Enum(Enum { name: "MigrationStatus", fields: Array([String("none"), String("setup"), String("cancelling"), String("cancelled"), String("active"), String("completed"), String("failed")]) }) }, Section { description: ["#", " @MigrationInfo", "", " Information about current migration process.", "", " @status: #optional @MigrationStatus describing the current migration status.", "          If this field is not returned, no migration process", "          has been initiated", "", " @ram: #optional @MigrationStats containing detailed migration", "       status, only returned if status is \"active\" or", "       \"completed\"(since 1.2)", "", " @disk: #optional @MigrationStats containing detailed disk migration", "        status, only returned if status is \"active\" and it is a block", "        migration", "", " @xbzrle-cache: #optional @XBZRLECacheStats containing detailed XBZRLE", "                migration statistics, only returned if XBZRLE feature is on and", "                status is \"active\" or \"completed\" (since 1.2)", "", " @total-time: #optional total amount of milliseconds since migration started.", "        If migration has ended, it returns the total migration", "        time. (since 1.2)", "", " @downtime: #optional only present when migration finishes correctly", "        total downtime in milliseconds for the guest.", "        (since 1.3)", "", " @expected-downtime: #optional only present while migration is active", "        expected downtime in milliseconds for the guest in last walk", "        of the dirty bitmap. (since 1.3)", "", " @setup-time: #optional amount of setup time in milliseconds _before_ the", "        iterations begin but _after_ the QMP command is issued. This is designed", "        to provide an accounting of any activities (such as RDMA pinning) which", "        may be expensive, but do not actually occur during the iterative", "        migration rounds themselves. (since 1.6)", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "MigrationInfo", fields: Object({"*disk": String("MigrationStats"), "*downtime": String("int"), "*expected-downtime": String("int"), "*ram": String("MigrationStats"), "*setup-time": String("int"), "*status": String("MigrationStatus"), "*total-time": String("int"), "*xbzrle-cache": String("XBZRLECacheStats")}), base: Null }) }, Section { description: ["#", " @query-migrate", "", " Returns information about current migration process.", "", " Returns: @MigrationInfo", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-migrate", fields: Null, gen: Null, returns: String("MigrationInfo") }) }, Section { description: ["#", " @MigrationCapability", "", " Migration capabilities enumeration", "", " @xbzrle: Migration supports xbzrle (Xor Based Zero Run Length Encoding).", "          This feature allows us to minimize migration traffic for certain work", "          loads, by sending compressed difference of the pages", "", " @rdma-pin-all: Controls whether or not the entire VM memory footprint is", "          mlock()\"d on demand or all at once. Refer to docs/rdma.txt for usage.", "          Disabled by default. (since 2.0)", "", " @zero-blocks: During storage migration encode blocks of zeroes efficiently. This", "          essentially saves 1MB of zeroes per block on the wire. Enabling requires", "          source and target VM to support this feature. To enable it is sufficient", "          to enable the capability on the source VM. The feature is disabled by", "          default. (since 1.6)", "", " @compress: Use multiple compression threads to accelerate live migration.", "          This feature can help to reduce the migration traffic, by sending", "          compressed pages. Please note that if compress and xbzrle are both", "          on, compress only takes effect in the ram bulk stage, after that,", "          it will be disabled and only xbzrle takes effect, this can help to", "          minimize migration traffic. The feature is disabled by default.", "          (since 2.4 )", "", " @auto-converge: If enabled, QEMU will automatically throttle down the guest", "          to speed up convergence of RAM migration. (since 1.6)", "", " Since: 1.2", "#"], qemu_type: Enum(Enum { name: "MigrationCapability", fields: Array([String("xbzrle"), String("rdma-pin-all"), String("auto-converge"), String("zero-blocks"), String("compress")]) }) }, Section { description: ["#", " @MigrationCapabilityStatus", "", " Migration capability information", "", " @capability: capability enum", "", " @state: capability state bool", "", " Since: 1.2", "#"], qemu_type: Struct(Struct { name: "MigrationCapabilityStatus", fields: Object({"capability": String("MigrationCapability"), "state": String("bool")}), base: Null }) }, Section { description: ["#", " @migrate-set-capabilities", "", " Enable/Disable the following migration capabilities (like xbzrle)", "", " @capabilities: json array of capability modifications to make", "", " Since: 1.2", "#"], qemu_type: Command(Command { name: "migrate-set-capabilities", fields: Object({"capabilities": Array([String("MigrationCapabilityStatus")])}), gen: Null, returns: Null }) }, Section { description: ["#", " @query-migrate-capabilities", "", " Returns information about the current migration capabilities status", "", " Returns: @MigrationCapabilitiesStatus", "", " Since: 1.2", "#"], qemu_type: Command(Command { name: "query-migrate-capabilities", fields: Null, gen: Null, returns: Array([String("MigrationCapabilityStatus")]) }) }, Section { description: [" @MigrationParameter", "", " Migration parameters enumeration", "", " @compress-level: Set the compression level to be used in live migration,", "          the compression level is an integer between 0 and 9, where 0 means", "          no compression, 1 means the best compression speed, and 9 means best", "          compression ratio which will consume more CPU.", "", " @compress-threads: Set compression thread count to be used in live migration,", "          the compression thread count is an integer between 1 and 255.", "", " @decompress-threads: Set decompression thread count to be used in live", "          migration, the decompression thread count is an integer between 1", "          and 255. Usually, decompression is at least 4 times as fast as", "          compression, so set the decompress-threads to the number about 1/4", "          of compress-threads is adequate.", "", " Since: 2.4", "#"], qemu_type: Enum(Enum { name: "MigrationParameter", fields: Array([String("compress-level"), String("compress-threads"), String("decompress-threads")]) }) }, Section { description: ["", " @migrate-set-parameters", "", " Set the following migration parameters", "", " @compress-level: compression level", "", " @compress-threads: compression thread count", "", " @decompress-threads: decompression thread count", "", " Since: 2.4", "#"], qemu_type: Command(Command { name: "migrate-set-parameters", fields: Object({"*compress-level": String("int"), "*compress-threads": String("int"), "*decompress-threads": String("int")}), gen: Null, returns: Null }) }, Section { description: ["", " @MigrationParameters", "", " @compress-level: compression level", "", " @compress-threads: compression thread count", "", " @decompress-threads: decompression thread count", "", " Since: 2.4", "#"], qemu_type: Struct(Struct { name: "MigrationParameters", fields: Object({"compress-level": String("int"), "compress-threads": String("int"), "decompress-threads": String("int")}), base: Null }) }, Section { description: ["#", " @query-migrate-parameters", "", " Returns information about the current migration parameters", "", " Returns: @MigrationParameters", "", " Since: 2.4", "#"], qemu_type: Command(Command { name: "query-migrate-parameters", fields: Null, gen: Null, returns: String("MigrationParameters") }) }, Section { description: ["#", " @MouseInfo:", "", " Information about a mouse device.", "", " @name: the name of the mouse device", "", " @index: the index of the mouse device", "", " @current: true if this device is currently receiving mouse events", "", " @absolute: true if this device supports absolute coordinates as input", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "MouseInfo", fields: Object({"absolute": String("bool"), "current": String("bool"), "index": String("int"), "name": String("str")}), base: Null }) }, Section { description: ["#", " @query-mice:", "", " Returns information about each active mouse device", "", " Returns: a list of @MouseInfo for each device", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-mice", fields: Null, gen: Null, returns: Array([String("MouseInfo")]) }) }, Section { description: ["#", " @CpuInfo:", "", " Information about a virtual CPU", "", " @CPU: the index of the virtual CPU", "", " @current: this only exists for backwards compatible and should be ignored", "", " @halted: true if the virtual CPU is in the halt state.  Halt usually refers", "          to a processor specific low power mode.", "", " @qom_path: path to the CPU object in the QOM tree (since 2.4)", "", " @pc: #optional If the target is i386 or x86_64, this is the 64-bit instruction", "                pointer.", "                If the target is Sparc, this is the PC component of the", "                instruction pointer.", "", " @nip: #optional If the target is PPC, the instruction pointer", "", " @npc: #optional If the target is Sparc, the NPC component of the instruction", "                 pointer", "", " @PC: #optional If the target is MIPS, the instruction pointer", "", " @thread_id: ID of the underlying host thread", "", " Since: 0.14.0", "", " Notes: @halted is a transient state that changes frequently.  By the time the", "        data is sent to the client, the guest may no longer be halted.", "#"], qemu_type: Struct(Struct { name: "CpuInfo", fields: Object({"*PC": String("int"), "*nip": String("int"), "*npc": String("int"), "*pc": String("int"), "CPU": String("int"), "current": String("bool"), "halted": String("bool"), "qom_path": String("str"), "thread_id": String("int")}), base: Null }) }, Section { description: ["#", " @query-cpus:", "", " Returns a list of information about each virtual CPU.", "", " Returns: a list of @CpuInfo for each virtual CPU", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-cpus", fields: Null, gen: Null, returns: Array([String("CpuInfo")]) }) }, Section { description: ["#", " @IOThreadInfo:", "", " Information about an iothread", "", " @id: the identifier of the iothread", "", " @thread-id: ID of the underlying host thread", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "IOThreadInfo", fields: Object({"id": String("str"), "thread-id": String("int")}), base: Null }) }, Section { description: ["#", " @query-iothreads:", "", " Returns a list of information about each iothread.", "", " Note this list excludes the QEMU main loop thread, which is not declared", " using the -object iothread command-line option.  It is always the main thread", " of the process.", "", " Returns: a list of @IOThreadInfo for each iothread", "", " Since: 2.0", "#"], qemu_type: Command(Command { name: "query-iothreads", fields: Null, gen: Null, returns: Array([String("IOThreadInfo")]) }) }, Section { description: ["#", " @NetworkAddressFamily", "", " The network address family", "", " @ipv4: IPV4 family", "", " @ipv6: IPV6 family", "", " @unix: unix socket", "", " @unknown: otherwise", "", " Since: 2.1", "#"], qemu_type: Enum(Enum { name: "NetworkAddressFamily", fields: Array([String("ipv4"), String("ipv6"), String("unix"), String("unknown")]) }) }, Section { description: ["#", " @VncBasicInfo", "", " The basic information for vnc network connection", "", " @host: IP address", "", " @service: The service name of the vnc port. This may depend on the host", "           system\"s service database so symbolic names should not be relied", "           on.", "", " @family: address family", "", " @websocket: true in case the socket is a websocket (since 2.3).", "", " Since: 2.1", "#"], qemu_type: Struct(Struct { name: "VncBasicInfo", fields: Object({"family": String("NetworkAddressFamily"), "host": String("str"), "service": String("str"), "websocket": String("bool")}), base: Null }) }, Section { description: ["#", " @VncServerInfo", "", " The network connection information for server", "", " @auth: #optional, authentication method", "", " Since: 2.1", "#"], qemu_type: Struct(Struct { name: "VncServerInfo", fields: Object({"*auth": String("str")}), base: String("VncBasicInfo") }) }, Section { description: ["#", " @VncClientInfo:", "", " Information about a connected VNC client.", "", " @x509_dname: #optional If x509 authentication is in use, the Distinguished", "              Name of the client.", "", " @sasl_username: #optional If SASL authentication is in use, the SASL username", "                 used for authentication.", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "VncClientInfo", fields: Object({"*sasl_username": String("str"), "*x509_dname": String("str")}), base: String("VncBasicInfo") }) }, Section { description: ["#", " @VncInfo:", "", " Information about the VNC session.", "", " @enabled: true if the VNC server is enabled, false otherwise", "", " @host: #optional The hostname the VNC server is bound to.  This depends on", "        the name resolution on the host and may be an IP address.", "", " @family: #optional \"ipv6\" if the host is listening for IPv6 connections", "                    \"ipv4\" if the host is listening for IPv4 connections", "                    \"unix\" if the host is listening on a unix domain socket", "                    \"unknown\" otherwise", "", " @service: #optional The service name of the server\"s port.  This may depends", "           on the host system\"s service database so symbolic names should not", "           be relied on.", "", " @auth: #optional the current authentication type used by the server", "        \"none\" if no authentication is being used", "        \"vnc\" if VNC authentication is being used", "        \"vencrypt+plain\" if VEncrypt is used with plain text authentication", "        \"vencrypt+tls+none\" if VEncrypt is used with TLS and no authentication", "        \"vencrypt+tls+vnc\" if VEncrypt is used with TLS and VNC authentication", "        \"vencrypt+tls+plain\" if VEncrypt is used with TLS and plain text auth", "        \"vencrypt+x509+none\" if VEncrypt is used with x509 and no auth", "        \"vencrypt+x509+vnc\" if VEncrypt is used with x509 and VNC auth", "        \"vencrypt+x509+plain\" if VEncrypt is used with x509 and plain text auth", "        \"vencrypt+tls+sasl\" if VEncrypt is used with TLS and SASL auth", "        \"vencrypt+x509+sasl\" if VEncrypt is used with x509 and SASL auth", "", " @clients: a list of @VncClientInfo of all currently connected clients", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "VncInfo", fields: Object({"*auth": String("str"), "*clients": Array([String("VncClientInfo")]), "*family": String("NetworkAddressFamily"), "*host": String("str"), "*service": String("str"), "enabled": String("bool")}), base: Null }) }, Section { description: ["#", " @VncPriAuth:", "", " vnc primary authentication method.", "", " Since: 2.3", "#"], qemu_type: Enum(Enum { name: "VncPrimaryAuth", fields: Array([String("none"), String("vnc"), String("ra2"), String("ra2ne"), String("tight"), String("ultra"), String("tls"), String("vencrypt"), String("sasl")]) }) }, Section { description: ["#", " @VncVencryptSubAuth:", "", " vnc sub authentication method with vencrypt.", "", " Since: 2.3", "#"], qemu_type: Enum(Enum { name: "VncVencryptSubAuth", fields: Array([String("plain"), String("tls-none"), String("x509-none"), String("tls-vnc"), String("x509-vnc"), String("tls-plain"), String("x509-plain"), String("tls-sasl"), String("x509-sasl")]) }) }, Section { description: ["#", " @VncInfo2:", "", " Information about a vnc server", "", " @id: vnc server name.", "", " @server: A list of @VncBasincInfo describing all listening sockets.", "          The list can be empty (in case the vnc server is disabled).", "          It also may have multiple entries: normal + websocket,", "          possibly also ipv4 + ipv6 in the future.", "", " @clients: A list of @VncClientInfo of all currently connected clients.", "           The list can be empty, for obvious reasons.", "", " @auth: The current authentication type used by the server", "", " @vencrypt: #optional The vencrypt sub authentication type used by the server,", "            only specified in case auth == vencrypt.", "", " @display: #optional The display device the vnc server is linked to.", "", " Since: 2.3", "#"], qemu_type: Struct(Struct { name: "VncInfo2", fields: Object({"*display": String("str"), "*vencrypt": String("VncVencryptSubAuth"), "auth": String("VncPrimaryAuth"), "clients": Array([String("VncClientInfo")]), "id": String("str"), "server": Array([String("VncBasicInfo")])}), base: Null }) }, Section { description: ["#", " @query-vnc:", "", " Returns information about the current VNC server", "", " Returns: @VncInfo", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-vnc", fields: Null, gen: Null, returns: String("VncInfo") }) }, Section { description: ["#", " @query-vnc-servers:", "", " Returns a list of vnc servers.  The list can be empty.", "", " Returns: a list of @VncInfo2", "", " Since: 2.3", "#"], qemu_type: Command(Command { name: "query-vnc-servers", fields: Null, gen: Null, returns: Array([String("VncInfo2")]) }) }, Section { description: ["#", " @SpiceBasicInfo", "", " The basic information for SPICE network connection", "", " @host: IP address", "", " @port: port number", "", " @family: address family", "", " Since: 2.1", "#"], qemu_type: Struct(Struct { name: "SpiceBasicInfo", fields: Object({"family": String("NetworkAddressFamily"), "host": String("str"), "port": String("str")}), base: Null }) }, Section { description: ["#", " @SpiceServerInfo", "", " Information about a SPICE server", "", " @auth: #optional, authentication method", "", " Since: 2.1", "#"], qemu_type: Struct(Struct { name: "SpiceServerInfo", fields: Object({"*auth": String("str")}), base: String("SpiceBasicInfo") }) }, Section { description: ["#", " @SpiceChannel", "", " Information about a SPICE client channel.", "", " @connection-id: SPICE connection id number.  All channels with the same id", "                 belong to the same SPICE session.", "", " @channel-type: SPICE channel type number.  \"1\" is the main control", "                channel, filter for this one if you want to track spice", "                sessions only", "", " @channel-id: SPICE channel ID number.  Usually \"0\", might be different when", "              multiple channels of the same type exist, such as multiple", "              display channels in a multihead setup", "", " @tls: true if the channel is encrypted, false otherwise.", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "SpiceChannel", fields: Object({"channel-id": String("int"), "channel-type": String("int"), "connection-id": String("int"), "tls": String("bool")}), base: String("SpiceBasicInfo") }) }, Section { description: ["#", " @SpiceQueryMouseMode", "", " An enumeration of Spice mouse states.", "", " @client: Mouse cursor position is determined by the client.", "", " @server: Mouse cursor position is determined by the server.", "", " @unknown: No information is available about mouse mode used by", "           the spice server.", "", " Note: spice/enums.h has a SpiceMouseMode already, hence the name.", "", " Since: 1.1", "#"], qemu_type: Enum(Enum { name: "SpiceQueryMouseMode", fields: Array([String("client"), String("server"), String("unknown")]) }) }, Section { description: ["#", " @SpiceInfo", "", " Information about the SPICE session.", "", " @enabled: true if the SPICE server is enabled, false otherwise", "", " @migrated: true if the last guest migration completed and spice", "            migration had completed as well. false otherwise.", "", " @host: #optional The hostname the SPICE server is bound to.  This depends on", "        the name resolution on the host and may be an IP address.", "", " @port: #optional The SPICE server\"s port number.", "", " @compiled-version: #optional SPICE server version.", "", " @tls-port: #optional The SPICE server\"s TLS port number.", "", " @auth: #optional the current authentication type used by the server", "        \"none\"  if no authentication is being used", "        \"spice\" uses SASL or direct TLS authentication, depending on command", "                line options", "", " @mouse-mode: The mode in which the mouse cursor is displayed currently. Can", "              be determined by the client or the server, or unknown if spice", "              server doesn\"t provide this information.", "", "              Since: 1.1", "", " @channels: a list of @SpiceChannel for each active spice channel", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "SpiceInfo", fields: Object({"*auth": String("str"), "*channels": Array([String("SpiceChannel")]), "*compiled-version": String("str"), "*host": String("str"), "*port": String("int"), "*tls-port": String("int"), "enabled": String("bool"), "migrated": String("bool"), "mouse-mode": String("SpiceQueryMouseMode")}), base: Null }) }, Section { description: ["#", " @query-spice", "", " Returns information about the current SPICE server", "", " Returns: @SpiceInfo", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-spice", fields: Null, gen: Null, returns: String("SpiceInfo") }) }, Section { description: ["#", " @BalloonInfo:", "", " Information about the guest balloon device.", "", " @actual: the number of bytes the balloon currently contains", "", " Since: 0.14.0", "", "#"], qemu_type: Struct(Struct { name: "BalloonInfo", fields: Object({"actual": String("int")}), base: Null }) }, Section { description: ["#", " @query-balloon:", "", " Return information about the balloon device.", "", " Returns: @BalloonInfo on success", "          If the balloon driver is enabled but not functional because the KVM", "          kernel module cannot support it, KvmMissingCap", "          If no balloon device is present, DeviceNotActive", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-balloon", fields: Null, gen: Null, returns: String("BalloonInfo") }) }, Section { description: ["#", " @PciMemoryRange:", "", " A PCI device memory region", "", " @base: the starting address (guest physical)", "", " @limit: the ending address (guest physical)", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "PciMemoryRange", fields: Object({"base": String("int"), "limit": String("int")}), base: Null }) }, Section { description: ["#", " @PciMemoryRegion", "", " Information about a PCI device I/O region.", "", " @bar: the index of the Base Address Register for this region", "", " @type: \"io\" if the region is a PIO region", "        \"memory\" if the region is a MMIO region", "", " @prefetch: #optional if @type is \"memory\", true if the memory is prefetchable", "", " @mem_type_64: #optional if @type is \"memory\", true if the BAR is 64-bit", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "PciMemoryRegion", fields: Object({"*mem_type_64": String("bool"), "*prefetch": String("bool"), "address": String("int"), "bar": String("int"), "size": String("int"), "type": String("str")}), base: Null }) }, Section { description: ["#", " @PciBusInfo:", "", " Information about a bus of a PCI Bridge device", "", " @number: primary bus interface number.  This should be the number of the", "          bus the device resides on.", "", " @secondary: secondary bus interface number.  This is the number of the", "             main bus for the bridge", "", " @subordinate: This is the highest number bus that resides below the", "               bridge.", "", " @io_range: The PIO range for all devices on this bridge", "", " @memory_range: The MMIO range for all devices on this bridge", "", " @prefetchable_range: The range of prefetchable MMIO for all devices on", "                      this bridge", "", " Since: 2.4", "#"], qemu_type: Struct(Struct { name: "PciBusInfo", fields: Object({"io_range": String("PciMemoryRange"), "memory_range": String("PciMemoryRange"), "number": String("int"), "prefetchable_range": String("PciMemoryRange"), "secondary": String("int"), "subordinate": String("int")}), base: Null }) }, Section { description: ["#", " @PciBridgeInfo:", "", " Information about a PCI Bridge device", "", " @bus: information about the bus the device resides on", "", " @devices: a list of @PciDeviceInfo for each device on this bridge", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "PciBridgeInfo", fields: Object({"*devices": Array([String("PciDeviceInfo")]), "bus": String("PciBusInfo")}), base: Null }) }, Section { description: ["#", " @PciDeviceClass:", "", " Information about the Class of a PCI device", "", " @desc: #optional a string description of the device\"s class", "", " @class: the class code of the device", "", " Since: 2.4", "#"], qemu_type: Struct(Struct { name: "PciDeviceClass", fields: Object({"*desc": String("str"), "class": String("int")}), base: Null }) }, Section { description: ["#", " @PciDeviceId:", "", " Information about the Id of a PCI device", "", " @device: the PCI device id", "", " @vendor: the PCI vendor id", "", " Since: 2.4", "#"], qemu_type: Struct(Struct { name: "PciDeviceId", fields: Object({"device": String("int"), "vendor": String("int")}), base: Null }) }, Section { description: ["#", " @PciDeviceInfo:", "", " Information about a PCI device", "", " @bus: the bus number of the device", "", " @slot: the slot the device is located in", "", " @function: the function of the slot used by the device", "", " @class_info: the class of the device", "", " @id: the PCI device id", "", " @irq: #optional if an IRQ is assigned to the device, the IRQ number", "", " @qdev_id: the device name of the PCI device", "", " @pci_bridge: if the device is a PCI bridge, the bridge information", "", " @regions: a list of the PCI I/O regions associated with the device", "", " Notes: the contents of @class_info.desc are not stable and should only be", "        treated as informational.", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "PciDeviceInfo", fields: Object({"*irq": String("int"), "*pci_bridge": String("PciBridgeInfo"), "bus": String("int"), "class_info": String("PciDeviceClass"), "function": String("int"), "id": String("PciDeviceId"), "qdev_id": String("str"), "regions": Array([String("PciMemoryRegion")]), "slot": String("int")}), base: Null }) }, Section { description: ["#", " @PciInfo:", "", " Information about a PCI bus", "", " @bus: the bus index", "", " @devices: a list of devices on this bus", "", " Since: 0.14.0", "#"], qemu_type: Struct(Struct { name: "PciInfo", fields: Object({"bus": String("int"), "devices": Array([String("PciDeviceInfo")])}), base: Null }) }, Section { description: ["#", " @query-pci:", "", " Return information about the PCI bus topology of the guest.", "", " Returns: a list of @PciInfo for each PCI bus", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "query-pci", fields: Null, gen: Null, returns: Array([String("PciInfo")]) }) }, Section { description: ["#", " @quit:", "", " This command will cause the QEMU process to exit gracefully.  While every", " attempt is made to send the QMP response before terminating, this is not", " guaranteed.  When using this interface, a premature EOF would not be", " unexpected.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "quit", fields: Null, gen: Null, returns: Null }) }, Section { description: ["#", " @stop:", "", " Stop all guest VCPU execution.", "", " Since:  0.14.0", "", " Notes:  This function will succeed even if the guest is already in the stopped", "         state.  In \"inmigrate\" state, it will ensure that the guest", "         remains paused once migration finishes, as if the -S option was", "         passed on the command line.", "#"], qemu_type: Command(Command { name: "stop", fields: Null, gen: Null, returns: Null }) }, Section { description: ["#", " @system_reset:", "", " Performs a hard reset of a guest.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "system_reset", fields: Null, gen: Null, returns: Null }) }, Section { description: ["#", " @system_powerdown:", "", " Requests that a guest perform a powerdown operation.", "", " Since: 0.14.0", "", " Notes: A guest may or may not respond to this command.  This command", "        returning does not indicate that a guest has accepted the request or", "        that it has shut down.  Many guests will respond to this command by", "        prompting the user in some way.", "#"], qemu_type: Command(Command { name: "system_powerdown", fields: Null, gen: Null, returns: Null }) }, Section { description: ["#", " @cpu:", "", " This command is a nop that is only provided for the purposes of compatibility.", "", " Since: 0.14.0", "", " Notes: Do not use this command.", "#"], qemu_type: Command(Command { name: "cpu", fields: Object({"index": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @cpu-add", "", " Adds CPU with specified ID", "", " @id: ID of CPU to be created, valid values [0..max_cpus)", "", " Returns: Nothing on success", "", " Since 1.5", "#"], qemu_type: Command(Command { name: "cpu-add", fields: Object({"id": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @memsave:", "", " Save a portion of guest memory to a file.", "", " @val: the virtual address of the guest to start from", "", " @size: the size of memory region to save", "", " @filename: the file to save the memory to as binary data", "", " @cpu-index: #optional the index of the virtual CPU to use for translating the", "                       virtual address (defaults to CPU 0)", "", " Returns: Nothing on success", "", " Since: 0.14.0", "", " Notes: Errors were not reliably returned until 1.1", "#"], qemu_type: Command(Command { name: "memsave", fields: Object({"*cpu-index": String("int"), "filename": String("str"), "size": String("int"), "val": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @pmemsave:", "", " Save a portion of guest physical memory to a file.", "", " @val: the physical address of the guest to start from", "", " @size: the size of memory region to save", "", " @filename: the file to save the memory to as binary data", "", " Returns: Nothing on success", "", " Since: 0.14.0", "", " Notes: Errors were not reliably returned until 1.1", "#"], qemu_type: Command(Command { name: "pmemsave", fields: Object({"filename": String("str"), "size": String("int"), "val": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @cont:", "", " Resume guest VCPU execution.", "", " Since:  0.14.0", "", " Returns:  If successful, nothing", "           If QEMU was started with an encrypted block device and a key has", "              not yet been set, DeviceEncrypted.", "", " Notes:  This command will succeed if the guest is currently running.  It", "         will also succeed if the guest is in the \"inmigrate\" state; in", "         this case, the effect of the command is to make sure the guest", "         starts once migration finishes, removing the effect of the -S", "         command line option if it was passed.", "#"], qemu_type: Command(Command { name: "cont", fields: Null, gen: Null, returns: Null }) }, Section { description: ["#", " @system_wakeup:", "", " Wakeup guest from suspend.  Does nothing in case the guest isn\"t suspended.", "", " Since:  1.1", "", " Returns:  nothing.", "#"], qemu_type: Command(Command { name: "system_wakeup", fields: Null, gen: Null, returns: Null }) }, Section { description: ["#", " @inject-nmi:", "", " Injects a Non-Maskable Interrupt into the default CPU (x86/s390) or all CPUs (ppc64).", "", " Returns:  If successful, nothing", "", " Since:  0.14.0", "", " Note: prior to 2.1, this command was only supported for x86 and s390 VMs", "#"], qemu_type: Command(Command { name: "inject-nmi", fields: Null, gen: Null, returns: Null }) }, Section { description: ["#", " @set_link:", "", " Sets the link status of a virtual network adapter.", "", " @name: the device name of the virtual network adapter", "", " @up: true to set the link status to be up", "", " Returns: Nothing on success", "          If @name is not a valid network device, DeviceNotFound", "", " Since: 0.14.0", "", " Notes: Not all network adapters support setting link status.  This command", "        will succeed even if the network adapter does not support link status", "        notification.", "#"], qemu_type: Command(Command { name: "set_link", fields: Object({"name": String("str"), "up": String("bool")}), gen: Null, returns: Null }) }, Section { description: ["#", " @balloon:", "", " Request the balloon driver to change its balloon size.", "", " @value: the target size of the balloon in bytes", "", " Returns: Nothing on success", "          If the balloon driver is enabled but not functional because the KVM", "            kernel module cannot support it, KvmMissingCap", "          If no balloon device is present, DeviceNotActive", "", " Notes: This command just issues a request to the guest.  When it returns,", "        the balloon size may not have changed.  A guest can change the balloon", "        size independent of this command.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "balloon", fields: Object({"value": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @Abort", "", " This action can be used to test transaction failure.", "", " Since: 1.6", "##"], qemu_type: Struct(Struct { name: "Abort", fields: Object({}), base: Null }) }, Section { description: ["#", " @TransactionAction", "", " A discriminated record of operations that can be performed with", " @transaction.", "", " Since 1.1", "", " drive-backup since 1.6", " abort since 1.6", " blockdev-snapshot-internal-sync since 1.7", " blockdev-backup since 2.3", "#"], qemu_type: Union(Union { name: "TransactionAction", discriminator: Null, data: Object({"abort": String("Abort"), "blockdev-backup": String("BlockdevBackup"), "blockdev-snapshot-internal-sync": String("BlockdevSnapshotInternal"), "blockdev-snapshot-sync": String("BlockdevSnapshot"), "drive-backup": String("DriveBackup")}) }) }, Section { description: ["#", " @transaction", "", " Executes a number of transactionable QMP commands atomically. If any", " operation fails, then the entire set of actions will be abandoned and the", " appropriate error returned.", "", "  List of:", "  @TransactionAction: information needed for the respective operation", "", " Returns: nothing on success", "          Errors depend on the operations of the transaction", "", " Note: The transaction aborts on the first failure.  Therefore, there will be", " information on only one failed operation returned in an error condition, and", " subsequent actions will not have been attempted.", "", " Since 1.1", "#"], qemu_type: Command(Command { name: "transaction", fields: Object({"actions": Array([String("TransactionAction")])}), gen: Null, returns: Null }) }, Section { description: ["#", " @human-monitor-command:", "", " Execute a command on the human monitor and return the output.", "", " @command-line: the command to execute in the human monitor", "", " @cpu-index: #optional The CPU to use for commands that require an implicit CPU", "", " Returns: the output of the command as a string", "", " Since: 0.14.0", "", " Notes: This command only exists as a stop-gap.  Its use is highly", "        discouraged.  The semantics of this command are not guaranteed.", "", "        Known limitations:", "", "        o This command is stateless, this means that commands that depend", "          on state information (such as getfd) might not work", "", "       o Commands that prompt the user for data (eg. \"cont\" when the block", "         device is encrypted) don\"t currently work", "#"], qemu_type: Command(Command { name: "human-monitor-command", fields: Object({"*cpu-index": String("int"), "command-line": String("str")}), gen: Null, returns: String("str") }) }, Section { description: ["#", " @migrate_cancel", "", " Cancel the current executing migration process.", "", " Returns: nothing on success", "", " Notes: This command succeeds even if there is no migration process running.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "migrate_cancel", fields: Null, gen: Null, returns: Null }) }, Section { description: ["#", " @migrate_set_downtime", "", " Set maximum tolerated downtime for migration.", "", " @value: maximum downtime in seconds", "", " Returns: nothing on success", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "migrate_set_downtime", fields: Object({"value": String("number")}), gen: Null, returns: Null }) }, Section { description: ["#", " @migrate_set_speed", "", " Set maximum speed for migration.", "", " @value: maximum speed in bytes.", "", " Returns: nothing on success", "", " Notes: A value lesser than zero will be automatically round up to zero.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "migrate_set_speed", fields: Object({"value": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @migrate-set-cache-size", "", " Set XBZRLE cache size", "", " @value: cache size in bytes", "", " The size will be rounded down to the nearest power of 2.", " The cache size can be modified before and during ongoing migration", "", " Returns: nothing on success", "", " Since: 1.2", "#"], qemu_type: Command(Command { name: "migrate-set-cache-size", fields: Object({"value": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @query-migrate-cache-size", "", " query XBZRLE cache size", "", " Returns: XBZRLE cache size in bytes", "", " Since: 1.2", "#"], qemu_type: Command(Command { name: "query-migrate-cache-size", fields: Null, gen: Null, returns: String("int") }) }, Section { description: ["#", " @ObjectPropertyInfo:", "", " @name: the name of the property", "", " @type: the type of the property.  This will typically come in one of four", "        forms:", "", "        1) A primitive type such as \"u8\", \"u16\", \"bool\", \"str\", or \"double\".", "           These types are mapped to the appropriate JSON type.", "", "        2) A legacy type in the form \"legacy<subtype>\" where subtype is the", "           legacy qdev typename.  These types are always treated as strings.", "", "        3) A child type in the form \"child<subtype>\" where subtype is a qdev", "           device type name.  Child properties create the composition tree.", "", "        4) A link type in the form \"link<subtype>\" where subtype is a qdev", "           device type name.  Link properties form the device model graph.", "", " Since: 1.2", "#"], qemu_type: Struct(Struct { name: "ObjectPropertyInfo", fields: Object({"name": String("str"), "type": String("str")}), base: Null }) }, Section { description: ["#", " @qom-list:", "", " This command will list any properties of a object given a path in the object", " model.", "", " @path: the path within the object model.  See @qom-get for a description of", "        this parameter.", "", " Returns: a list of @ObjectPropertyInfo that describe the properties of the", "          object.", "", " Since: 1.2", "#"], qemu_type: Command(Command { name: "qom-list", fields: Object({"path": String("str")}), gen: Null, returns: Array([String("ObjectPropertyInfo")]) }) }, Section { description: ["#", " @qom-get:", "", " This command will get a property from a object model path and return the", " value.", "", " @path: The path within the object model.  There are two forms of supported", "        paths--absolute and partial paths.", "", "        Absolute paths are derived from the root object and can follow child<>", "        or link<> properties.  Since they can follow link<> properties, they", "        can be arbitrarily long.  Absolute paths look like absolute filenames", "        and are prefixed  with a leading slash.", "", "        Partial paths look like relative filenames.  They do not begin", "        with a prefix.  The matching rules for partial paths are subtle but", "        designed to make specifying objects easy.  At each level of the", "        composition tree, the partial path is matched as an absolute path.", "        The first match is not returned.  At least two matches are searched", "        for.  A successful result is only returned if only one match is", "        found.  If more than one match is found, a flag is return to", "        indicate that the match was ambiguous.", "", " @property: The property name to read", "", " Returns: The property value.  The type depends on the property type.  legacy<>", "          properties are returned as #str.  child<> and link<> properties are", "          returns as #str pathnames.  All integer property types (u8, u16, etc)", "          are returned as #int.", "", " Since: 1.2", "#"], qemu_type: Command(Command { name: "qom-get", fields: Object({"path": String("str"), "property": String("str")}), gen: Boolean(false), returns: String("**") }) }, Section { description: ["#", " @qom-set:", "", " This command will set a property from a object model path.", "", " @path: see @qom-get for a description of this parameter", "", " @property: the property name to set", "", " @value: a value who\"s type is appropriate for the property type.  See @qom-get", "         for a description of type mapping.", "", " Since: 1.2", "#"], qemu_type: Command(Command { name: "qom-set", fields: Object({"path": String("str"), "property": String("str"), "value": String("**")}), gen: Boolean(false), returns: Null }) }, Section { description: ["#", " @set_password:", "", " Sets the password of a remote display session.", "", " @protocol: `vnc\" to modify the VNC server password", "            `spice\" to modify the Spice server password", "", " @password: the new password", "", " @connected: #optional how to handle existing clients when changing the", "                       password.  If nothing is specified, defaults to `keep\"", "                       `fail\" to fail the command if clients are connected", "                       `disconnect\" to disconnect existing clients", "                       `keep\" to maintain existing clients", "", " Returns: Nothing on success", "          If Spice is not enabled, DeviceNotFound", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "set_password", fields: Object({"*connected": String("str"), "password": String("str"), "protocol": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @expire_password:", "", " Expire the password of a remote display server.", "", " @protocol: the name of the remote display protocol `vnc\" or `spice\"", "", " @time: when to expire the password.", "        `now\" to expire the password immediately", "        `never\" to cancel password expiration", "        `+INT\" where INT is the number of seconds from now (integer)", "        `INT\" where INT is the absolute time in seconds", "", " Returns: Nothing on success", "          If @protocol is `spice\" and Spice is not active, DeviceNotFound", "", " Since: 0.14.0", "", " Notes: Time is relative to the server and currently there is no way to", "        coordinate server time with client time.  It is not recommended to", "        use the absolute time version of the @time parameter unless you\"re", "        sure you are on the same machine as the QEMU instance.", "#"], qemu_type: Command(Command { name: "expire_password", fields: Object({"protocol": String("str"), "time": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @change-vnc-password:", "", " Change the VNC server password.", "", " @password:  the new password to use with VNC authentication", "", " Since: 1.1", "", " Notes:  An empty password in this command will set the password to the empty", "         string.  Existing clients are unaffected by executing this command.", "#"], qemu_type: Command(Command { name: "change-vnc-password", fields: Object({"password": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @change:", "", " This command is multiple commands multiplexed together.", "", " @device: This is normally the name of a block device but it may also be \"vnc\".", "          when it\"s \"vnc\", then sub command depends on @target", "", " @target: If @device is a block device, then this is the new filename.", "          If @device is \"vnc\", then if the value \"password\" selects the vnc", "          change password command.   Otherwise, this specifies a new server URI", "          address to listen to for VNC connections.", "", " @arg:    If @device is a block device, then this is an optional format to open", "          the device with.", "          If @device is \"vnc\" and @target is \"password\", this is the new VNC", "          password to set.  If this argument is an empty string, then no future", "          logins will be allowed.", "", " Returns: Nothing on success.", "          If @device is not a valid block device, DeviceNotFound", "          If the new block device is encrypted, DeviceEncrypted.  Note that", "          if this error is returned, the device has been opened successfully", "          and an additional call to @block_passwd is required to set the", "          device\"s password.  The behavior of reads and writes to the block", "          device between when these calls are executed is undefined.", "", " Notes:  It is strongly recommended that this interface is not used especially", "         for changing block devices.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "change", fields: Object({"*arg": String("str"), "device": String("str"), "target": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @ObjectTypeInfo:", "", " This structure describes a search result from @qom-list-types", "", " @name: the type name found in the search", "", " Since: 1.1", "", " Notes: This command is experimental and may change syntax in future releases.", "#"], qemu_type: Struct(Struct { name: "ObjectTypeInfo", fields: Object({"name": String("str")}), base: Null }) }, Section { description: ["#", " @qom-list-types:", "", " This command will return a list of types given search parameters", "", " @implements: if specified, only return types that implement this type name", "", " @abstract: if true, include abstract types in the results", "", " Returns: a list of @ObjectTypeInfo or an empty list if no results are found", "", " Since: 1.1", "#"], qemu_type: Command(Command { name: "qom-list-types", fields: Object({"*abstract": String("bool"), "*implements": String("str")}), gen: Null, returns: Array([String("ObjectTypeInfo")]) }) }, Section { description: ["#", " @DevicePropertyInfo:", "", " Information about device properties.", "", " @name: the name of the property", " @type: the typename of the property", " @description: #optional if specified, the description of the property.", "               (since 2.2)", "", " Since: 1.2", "#"], qemu_type: Struct(Struct { name: "DevicePropertyInfo", fields: Object({"*description": String("str"), "name": String("str"), "type": String("str")}), base: Null }) }, Section { description: ["#", " @device-list-properties:", "", " List properties associated with a device.", "", " @typename: the type name of a device", "", " Returns: a list of DevicePropertyInfo describing a devices properties", "", " Since: 1.2", "#"], qemu_type: Command(Command { name: "device-list-properties", fields: Object({"typename": String("str")}), gen: Null, returns: Array([String("DevicePropertyInfo")]) }) }, Section { description: ["#", " @migrate", "", " Migrates the current running guest to another Virtual Machine.", "", " @uri: the Uniform Resource Identifier of the destination VM", "", " @blk: #optional do block migration (full disk copy)", "", " @inc: #optional incremental disk copy migration", "", " @detach: this argument exists only for compatibility reasons and", "          is ignored by QEMU", "", " Returns: nothing on success", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "migrate", fields: Object({"*blk": String("bool"), "*detach": String("bool"), "*inc": String("bool"), "uri": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @migrate-incoming", "", " Start an incoming migration, the qemu must have been started", " with -incoming defer", "", " @uri: The Uniform Resource Identifier identifying the source or", "       address to listen on", "", " Returns: nothing on success", "", " Since: 2.3", " Note: It\"s a bad idea to use a string for the uri, but it needs to stay", " compatible with -incoming and the format of the uri is already exposed", " above libvirt", "#"], qemu_type: Command(Command { name: "migrate-incoming", fields: Object({"uri": String("str")}), gen: Null, returns: Null }) }, Section { description: [" @xen-save-devices-state:", "", " Save the state of all devices to file. The RAM and the block devices", " of the VM are not saved by this command.", "", " @filename: the file to save the state of the devices to as binary", " data. See xen-save-devices-state.txt for a description of the binary", " format.", "", " Returns: Nothing on success", "", " Since: 1.1", "#"], qemu_type: Command(Command { name: "xen-save-devices-state", fields: Object({"filename": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @xen-set-global-dirty-log", "", " Enable or disable the global dirty log mode.", "", " @enable: true to enable, false to disable.", "", " Returns: nothing", "", " Since: 1.3", "#"], qemu_type: Command(Command { name: "xen-set-global-dirty-log", fields: Object({"enable": String("bool")}), gen: Null, returns: Null }) }, Section { description: ["#", " @device_del:", "", " Remove a device from a guest", "", " @id: the name of the device", "", " Returns: Nothing on success", "          If @id is not a valid device, DeviceNotFound", "", " Notes: When this command completes, the device may not be removed from the", "        guest.  Hot removal is an operation that requires guest cooperation.", "        This command merely requests that the guest begin the hot removal", "        process.  Completion of the device removal process is signaled with a", "        DEVICE_DELETED event. Guest reset will automatically complete removal", "        for all devices.", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "device_del", fields: Object({"id": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @DumpGuestMemoryFormat:", "", " An enumeration of guest-memory-dump\"s format.", "", " @elf: elf format", "", " @kdump-zlib: kdump-compressed format with zlib-compressed", "", " @kdump-lzo: kdump-compressed format with lzo-compressed", "", " @kdump-snappy: kdump-compressed format with snappy-compressed", "", " Since: 2.0", "#"], qemu_type: Enum(Enum { name: "DumpGuestMemoryFormat", fields: Array([String("elf"), String("kdump-zlib"), String("kdump-lzo"), String("kdump-snappy")]) }) }, Section { description: ["#", " @dump-guest-memory", "", " Dump guest\"s memory to vmcore. It is a synchronous operation that can take", " very long depending on the amount of guest memory. This command is only", " supported on i386 and x86_64.", "", " @paging: if true, do paging to get guest\"s memory mapping. This allows", "          using gdb to process the core file.", "", "          IMPORTANT: this option can make QEMU allocate several gigabytes", "                     of RAM. This can happen for a large guest, or a", "                     malicious guest pretending to be large.", "", "          Also, paging=true has the following limitations:", "", "             1. The guest may be in a catastrophic state or can have corrupted", "                memory, which cannot be trusted", "             2. The guest can be in real-mode even if paging is enabled. For", "                example, the guest uses ACPI to sleep, and ACPI sleep state", "                goes in real-mode", "", " @protocol: the filename or file descriptor of the vmcore. The supported", "            protocols are:", "", "            1. file: the protocol starts with \"file:\", and the following", "               string is the file\"s path.", "            2. fd: the protocol starts with \"fd:\", and the following string", "               is the fd\"s name.", "", " @begin: #optional if specified, the starting physical address.", "", " @length: #optional if specified, the memory size, in bytes. If you don\"t", "          want to dump all guest\"s memory, please specify the start @begin", "          and @length", "", " @format: #optional if specified, the format of guest memory dump. But non-elf", "          format is conflict with paging and filter, ie. @paging, @begin and", "          @length is not allowed to be specified with non-elf @format at the", "          same time (since 2.0)", "", " Returns: nothing on success", "", " Since: 1.2", "#"], qemu_type: Command(Command { name: "dump-guest-memory", fields: Object({"*begin": String("int"), "*format": String("DumpGuestMemoryFormat"), "*length": String("int"), "paging": String("bool"), "protocol": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @DumpGuestMemoryCapability:", "", " A list of the available formats for dump-guest-memory", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "DumpGuestMemoryCapability", fields: Object({"formats": Array([String("DumpGuestMemoryFormat")])}), base: Null }) }, Section { description: ["#", " @query-dump-guest-memory-capability:", "", " Returns the available formats for dump-guest-memory", "", " Returns:  A @DumpGuestMemoryCapability object listing available formats for", "           dump-guest-memory", "", " Since: 2.0", "#"], qemu_type: Command(Command { name: "query-dump-guest-memory-capability", fields: Null, gen: Null, returns: String("DumpGuestMemoryCapability") }) }, Section { description: ["#", " @netdev_add:", "", " Add a network backend.", "", " @type: the type of network backend.  Current valid values are \"user\", \"tap\",", "        \"vde\", \"socket\", \"dump\" and \"bridge\"", "", " @id: the name of the new network backend", "", " @props: #optional a list of properties to be passed to the backend in", "         the format \"name=value\", like \"ifname=tap0,script=no\"", "", " Notes: The semantics of @props is not well defined.  Future commands will be", "        introduced that provide stronger typing for backend creation.", "", " Since: 0.14.0", "", " Returns: Nothing on success", "          If @type is not a valid network backend, DeviceNotFound", "#"], qemu_type: Command(Command { name: "netdev_add", fields: Object({"*props": String("**"), "id": String("str"), "type": String("str")}), gen: Boolean(false), returns: Null }) }, Section { description: ["#", " @netdev_del:", "", " Remove a network backend.", "", " @id: the name of the network backend to remove", "", " Returns: Nothing on success", "          If @id is not a valid network backend, DeviceNotFound", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "netdev_del", fields: Object({"id": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @object-add:", "", " Create a QOM object.", "", " @qom-type: the class name for the object to be created", "", " @id: the name of the new object", "", " @props: #optional a dictionary of properties to be passed to the backend", "", " Returns: Nothing on success", "          Error if @qom-type is not a valid class name", "", " Since: 2.0", "#"], qemu_type: Command(Command { name: "object-add", fields: Object({"*props": String("**"), "id": String("str"), "qom-type": String("str")}), gen: Boolean(false), returns: Null }) }, Section { description: ["#", " @object-del:", "", " Remove a QOM object.", "", " @id: the name of the QOM object to remove", "", " Returns: Nothing on success", "          Error if @id is not a valid id for a QOM object", "", " Since: 2.0", "#"], qemu_type: Command(Command { name: "object-del", fields: Object({"id": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @NetdevNoneOptions", "", " Use it alone to have zero network devices.", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetdevNoneOptions", fields: Object({}), base: Null }) }, Section { description: ["#", " @NetLegacyNicOptions", "", " Create a new Network Interface Card.", "", " @netdev: #optional id of -netdev to connect to", "", " @macaddr: #optional MAC address", "", " @model: #optional device model (e1000, rtl8139, virtio etc.)", "", " @addr: #optional PCI device address", "", " @vectors: #optional number of MSI-x vectors, 0 to disable MSI-X", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetLegacyNicOptions", fields: Object({"*addr": String("str"), "*macaddr": String("str"), "*model": String("str"), "*netdev": String("str"), "*vectors": String("uint32")}), base: Null }) }, Section { description: ["#", " @String", "", " A fat type wrapping \"str\", to be embedded in lists.", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "String", fields: Object({"str": String("str")}), base: Null }) }, Section { description: ["#", " @NetdevUserOptions", "", " Use the user mode network stack which requires no administrator privilege to", " run.", "", " @hostname: #optional client hostname reported by the builtin DHCP server", "", " @restrict: #optional isolate the guest from the host", "", " @ip: #optional legacy parameter, use net= instead", "", " @net: #optional IP address and optional netmask", "", " @host: #optional guest-visible address of the host", "", " @tftp: #optional root directory of the built-in TFTP server", "", " @bootfile: #optional BOOTP filename, for use with tftp=", "", " @dhcpstart: #optional the first of the 16 IPs the built-in DHCP server can", "             assign", "", " @dns: #optional guest-visible address of the virtual nameserver", "", " @dnssearch: #optional list of DNS suffixes to search, passed as DHCP option", "             to the guest", "", " @smb: #optional root directory of the built-in SMB server", "", " @smbserver: #optional IP address of the built-in SMB server", "", " @hostfwd: #optional redirect incoming TCP or UDP host connections to guest", "           endpoints", "", " @guestfwd: #optional forward guest TCP connections", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetdevUserOptions", fields: Object({"*bootfile": String("str"), "*dhcpstart": String("str"), "*dns": String("str"), "*dnssearch": Array([String("String")]), "*guestfwd": Array([String("String")]), "*host": String("str"), "*hostfwd": Array([String("String")]), "*hostname": String("str"), "*ip": String("str"), "*net": String("str"), "*restrict": String("bool"), "*smb": String("str"), "*smbserver": String("str"), "*tftp": String("str")}), base: Null }) }, Section { description: ["#", " @NetdevTapOptions", "", " Connect the host TAP network interface name to the VLAN.", "", " @ifname: #optional interface name", "", " @fd: #optional file descriptor of an already opened tap", "", " @fds: #optional multiple file descriptors of already opened multiqueue capable", " tap", "", " @script: #optional script to initialize the interface", "", " @downscript: #optional script to shut down the interface", "", " @helper: #optional command to execute to configure bridge", "", " @sndbuf: #optional send buffer limit. Understands [TGMKkb] suffixes.", "", " @vnet_hdr: #optional enable the IFF_VNET_HDR flag on the tap interface", "", " @vhost: #optional enable vhost-net network accelerator", "", " @vhostfd: #optional file descriptor of an already opened vhost net device", "", " @vhostfds: #optional file descriptors of multiple already opened vhost net", " devices", "", " @vhostforce: #optional vhost on for non-MSIX virtio guests", "", " @queues: #optional number of queues to be created for multiqueue capable tap", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetdevTapOptions", fields: Object({"*downscript": String("str"), "*fd": String("str"), "*fds": String("str"), "*helper": String("str"), "*ifname": String("str"), "*queues": String("uint32"), "*script": String("str"), "*sndbuf": String("size"), "*vhost": String("bool"), "*vhostfd": String("str"), "*vhostfds": String("str"), "*vhostforce": String("bool"), "*vnet_hdr": String("bool")}), base: Null }) }, Section { description: ["#", " @NetdevSocketOptions", "", " Connect the VLAN to a remote VLAN in another QEMU virtual machine using a TCP", " socket connection.", "", " @fd: #optional file descriptor of an already opened socket", "", " @listen: #optional port number, and optional hostname, to listen on", "", " @connect: #optional port number, and optional hostname, to connect to", "", " @mcast: #optional UDP multicast address and port number", "", " @localaddr: #optional source address and port for multicast and udp packets", "", " @udp: #optional UDP unicast address and port number", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetdevSocketOptions", fields: Object({"*connect": String("str"), "*fd": String("str"), "*listen": String("str"), "*localaddr": String("str"), "*mcast": String("str"), "*udp": String("str")}), base: Null }) }, Section { description: ["#", " @NetdevL2TPv3Options", "", " Connect the VLAN to Ethernet over L2TPv3 Static tunnel", "", " @src: source address", "", " @dst: destination address", "", " @srcport: #optional source port - mandatory for udp, optional for ip", "", " @dstport: #optional destination port - mandatory for udp, optional for ip", "", " @ipv6: #optional - force the use of ipv6", "", " @udp: #optional - use the udp version of l2tpv3 encapsulation", "", " @cookie64: #optional - use 64 bit coookies", "", " @counter: #optional have sequence counter", "", " @pincounter: #optional pin sequence counter to zero -", "              workaround for buggy implementations or", "              networks with packet reorder", "", " @txcookie: #optional 32 or 64 bit transmit cookie", "", " @rxcookie: #optional 32 or 64 bit receive cookie", "", " @txsession: 32 bit transmit session", "", " @rxsession: #optional 32 bit receive session - if not specified", "             set to the same value as transmit", "", " @offset: #optional additional offset - allows the insertion of", "          additional application-specific data before the packet payload", "", " Since 2.1", "#"], qemu_type: Struct(Struct { name: "NetdevL2TPv3Options", fields: Object({"*cookie64": String("bool"), "*counter": String("bool"), "*dstport": String("str"), "*ipv6": String("bool"), "*offset": String("uint32"), "*pincounter": String("bool"), "*rxcookie": String("uint64"), "*rxsession": String("uint32"), "*srcport": String("str"), "*txcookie": String("uint64"), "*udp": String("bool"), "dst": String("str"), "src": String("str"), "txsession": String("uint32")}), base: Null }) }, Section { description: ["#", " @NetdevVdeOptions", "", " Connect the VLAN to a vde switch running on the host.", "", " @sock: #optional socket path", "", " @port: #optional port number", "", " @group: #optional group owner of socket", "", " @mode: #optional permissions for socket", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetdevVdeOptions", fields: Object({"*group": String("str"), "*mode": String("uint16"), "*port": String("uint16"), "*sock": String("str")}), base: Null }) }, Section { description: ["#", " @NetdevDumpOptions", "", " Dump VLAN network traffic to a file.", "", " @len: #optional per-packet size limit (64k default). Understands [TGMKkb]", " suffixes.", "", " @file: #optional dump file path (default is qemu-vlan0.pcap)", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetdevDumpOptions", fields: Object({"*file": String("str"), "*len": String("size")}), base: Null }) }, Section { description: ["#", " @NetdevBridgeOptions", "", " Connect a host TAP network interface to a host bridge device.", "", " @br: #optional bridge name", "", " @helper: #optional command to execute to configure bridge", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetdevBridgeOptions", fields: Object({"*br": String("str"), "*helper": String("str")}), base: Null }) }, Section { description: ["#", " @NetdevHubPortOptions", "", " Connect two or more net clients through a software hub.", "", " @hubid: hub identifier number", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetdevHubPortOptions", fields: Object({"hubid": String("int32")}), base: Null }) }, Section { description: ["#", " @NetdevNetmapOptions", "", " Connect a client to a netmap-enabled NIC or to a VALE switch port", "", " @ifname: Either the name of an existing network interface supported by", "          netmap, or the name of a VALE port (created on the fly).", "          A VALE port name is in the form \"valeXXX:YYY\", where XXX and", "          YYY are non-negative integers. XXX identifies a switch and", "          YYY identifies a port of the switch. VALE ports having the", "          same XXX are therefore connected to the same switch.", "", " @devname: #optional path of the netmap device (default: \"/dev/netmap\").", "", " Since 2.0", "#"], qemu_type: Struct(Struct { name: "NetdevNetmapOptions", fields: Object({"*devname": String("str"), "ifname": String("str")}), base: Null }) }, Section { description: ["#", " @NetdevVhostUserOptions", "", " Vhost-user network backend", "", " @chardev: name of a unix socket chardev", "", " @vhostforce: #optional vhost on for non-MSIX virtio guests (default: false).", "", " Since 2.1", "#"], qemu_type: Struct(Struct { name: "NetdevVhostUserOptions", fields: Object({"*vhostforce": String("bool"), "chardev": String("str")}), base: Null }) }, Section { description: ["#", " @NetClientOptions", "", " A discriminated record of network device traits.", "", " Since 1.2", "", " \"l2tpv3\" - since 2.1", "", "#"], qemu_type: Union(Union { name: "NetClientOptions", discriminator: Null, data: Object({"bridge": String("NetdevBridgeOptions"), "dump": String("NetdevDumpOptions"), "hubport": String("NetdevHubPortOptions"), "l2tpv3": String("NetdevL2TPv3Options"), "netmap": String("NetdevNetmapOptions"), "nic": String("NetLegacyNicOptions"), "none": String("NetdevNoneOptions"), "socket": String("NetdevSocketOptions"), "tap": String("NetdevTapOptions"), "user": String("NetdevUserOptions"), "vde": String("NetdevVdeOptions"), "vhost-user": String("NetdevVhostUserOptions")}) }) }, Section { description: ["#", " @NetLegacy", "", " Captures the configuration of a network device; legacy.", "", " @vlan: #optional vlan number", "", " @id: #optional identifier for monitor commands", "", " @name: #optional identifier for monitor commands, ignored if @id is present", "", " @opts: device type specific properties (legacy)", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "NetLegacy", fields: Object({"*id": String("str"), "*name": String("str"), "*vlan": String("int32"), "opts": String("NetClientOptions")}), base: Null }) }, Section { description: ["#", " @Netdev", "", " Captures the configuration of a network device.", "", " @id: identifier for monitor commands.", "", " @opts: device type specific properties", "", " Since 1.2", "#"], qemu_type: Struct(Struct { name: "Netdev", fields: Object({"id": String("str"), "opts": String("NetClientOptions")}), base: Null }) }, Section { description: ["#", " @InetSocketAddress", "", " Captures a socket address or address range in the Internet namespace.", "", " @host: host part of the address", "", " @port: port part of the address, or lowest port if @to is present", "", " @to: highest port to try", "", " @ipv4: whether to accept IPv4 addresses, default try both IPv4 and IPv6", "        #optional", "", " @ipv6: whether to accept IPv6 addresses, default try both IPv4 and IPv6", "        #optional", "", " Since 1.3", "#"], qemu_type: Struct(Struct { name: "InetSocketAddress", fields: Object({"*ipv4": String("bool"), "*ipv6": String("bool"), "*to": String("uint16"), "host": String("str"), "port": String("str")}), base: Null }) }, Section { description: ["#", " @UnixSocketAddress", "", " Captures a socket address in the local (\"Unix socket\") namespace.", "", " @path: filesystem path to use", "", " Since 1.3", "#"], qemu_type: Struct(Struct { name: "UnixSocketAddress", fields: Object({"path": String("str")}), base: Null }) }, Section { description: ["#", " @SocketAddress", "", " Captures the address of a socket, which could also be a named file descriptor", "", " Since 1.3", "#"], qemu_type: Union(Union { name: "SocketAddress", discriminator: Null, data: Object({"fd": String("String"), "inet": String("InetSocketAddress"), "unix": String("UnixSocketAddress")}) }) }, Section { description: ["#", " @getfd:", "", " Receive a file descriptor via SCM rights and assign it a name", "", " @fdname: file descriptor name", "", " Returns: Nothing on success", "", " Since: 0.14.0", "", " Notes: If @fdname already exists, the file descriptor assigned to", "        it will be closed and replaced by the received file", "        descriptor.", "        The \"closefd\" command can be used to explicitly close the", "        file descriptor when it is no longer needed.", "#"], qemu_type: Command(Command { name: "getfd", fields: Object({"fdname": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @closefd:", "", " Close a file descriptor previously passed via SCM rights", "", " @fdname: file descriptor name", "", " Returns: Nothing on success", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "closefd", fields: Object({"fdname": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @MachineInfo:", "", " Information describing a machine.", "", " @name: the name of the machine", "", " @alias: #optional an alias for the machine name", "", " @default: #optional whether the machine is default", "", " @cpu-max: maximum number of CPUs supported by the machine type", "           (since 1.5.0)", "", " Since: 1.2.0", "#"], qemu_type: Struct(Struct { name: "MachineInfo", fields: Object({"*alias": String("str"), "*is-default": String("bool"), "cpu-max": String("int"), "name": String("str")}), base: Null }) }, Section { description: ["#", " @query-machines:", "", " Return a list of supported machines", "", " Returns: a list of MachineInfo", "", " Since: 1.2.0", "#"], qemu_type: Command(Command { name: "query-machines", fields: Null, gen: Null, returns: Array([String("MachineInfo")]) }) }, Section { description: ["#", " @CpuDefinitionInfo:", "", " Virtual CPU definition.", "", " @name: the name of the CPU definition", "", " Since: 1.2.0", "#"], qemu_type: Struct(Struct { name: "CpuDefinitionInfo", fields: Object({"name": String("str")}), base: Null }) }, Section { description: ["#", " @query-cpu-definitions:", "", " Return a list of supported virtual CPU definitions", "", " Returns: a list of CpuDefInfo", "", " Since: 1.2.0", "#"], qemu_type: Command(Command { name: "query-cpu-definitions", fields: Null, gen: Null, returns: Array([String("CpuDefinitionInfo")]) }) }, Section { description: [" @AddfdInfo:", "", " Information about a file descriptor that was added to an fd set.", "", " @fdset-id: The ID of the fd set that @fd was added to.", "", " @fd: The file descriptor that was received via SCM rights and", "      added to the fd set.", "", " Since: 1.2.0", "#"], qemu_type: Struct(Struct { name: "AddfdInfo", fields: Object({"fd": String("int"), "fdset-id": String("int")}), base: Null }) }, Section { description: ["#", " @add-fd:", "", " Add a file descriptor, that was passed via SCM rights, to an fd set.", "", " @fdset-id: #optional The ID of the fd set to add the file descriptor to.", "", " @opaque: #optional A free-form string that can be used to describe the fd.", "", " Returns: @AddfdInfo on success", "          If file descriptor was not received, FdNotSupplied", "          If @fdset-id is a negative value, InvalidParameterValue", "", " Notes: The list of fd sets is shared by all monitor connections.", "", "        If @fdset-id is not specified, a new fd set will be created.", "", " Since: 1.2.0", "#"], qemu_type: Command(Command { name: "add-fd", fields: Object({"*fdset-id": String("int"), "*opaque": String("str")}), gen: Null, returns: String("AddfdInfo") }) }, Section { description: ["#", " @remove-fd:", "", " Remove a file descriptor from an fd set.", "", " @fdset-id: The ID of the fd set that the file descriptor belongs to.", "", " @fd: #optional The file descriptor that is to be removed.", "", " Returns: Nothing on success", "          If @fdset-id or @fd is not found, FdNotFound", "", " Since: 1.2.0", "", " Notes: The list of fd sets is shared by all monitor connections.", "", "        If @fd is not specified, all file descriptors in @fdset-id", "        will be removed.", "#"], qemu_type: Command(Command { name: "remove-fd", fields: Object({"*fd": String("int"), "fdset-id": String("int")}), gen: Null, returns: Null }) }, Section { description: ["#", " @FdsetFdInfo:", "", " Information about a file descriptor that belongs to an fd set.", "", " @fd: The file descriptor value.", "", " @opaque: #optional A free-form string that can be used to describe the fd.", "", " Since: 1.2.0", "#"], qemu_type: Struct(Struct { name: "FdsetFdInfo", fields: Object({"*opaque": String("str"), "fd": String("int")}), base: Null }) }, Section { description: ["#", " @FdsetInfo:", "", " Information about an fd set.", "", " @fdset-id: The ID of the fd set.", "", " @fds: A list of file descriptors that belong to this fd set.", "", " Since: 1.2.0", "#"], qemu_type: Struct(Struct { name: "FdsetInfo", fields: Object({"fds": Array([String("FdsetFdInfo")]), "fdset-id": String("int")}), base: Null }) }, Section { description: ["#", " @query-fdsets:", "", " Return information describing all fd sets.", "", " Returns: A list of @FdsetInfo", "", " Since: 1.2.0", "", " Note: The list of fd sets is shared by all monitor connections.", "", "#"], qemu_type: Command(Command { name: "query-fdsets", fields: Null, gen: Null, returns: Array([String("FdsetInfo")]) }) }, Section { description: ["#", " @TargetInfo:", "", " Information describing the QEMU target.", "", " @arch: the target architecture (eg \"x86_64\", \"i386\", etc)", "", " Since: 1.2.0", "#"], qemu_type: Struct(Struct { name: "TargetInfo", fields: Object({"arch": String("str")}), base: Null }) }, Section { description: ["#", " @query-target:", "", " Return information about the target for this QEMU", "", " Returns: TargetInfo", "", " Since: 1.2.0", "#"], qemu_type: Command(Command { name: "query-target", fields: Null, gen: Null, returns: String("TargetInfo") }) }, Section { description: ["#", " @QKeyCode:", "", " An enumeration of key name.", "", " This is used by the send-key command.", "", " Since: 1.3.0", "", " \"unmapped\" and \"pause\" since 2.0", "#"], qemu_type: Enum(Enum { name: "QKeyCode", fields: Array([String("unmapped"), String("shift"), String("shift_r"), String("alt"), String("alt_r"), String("altgr"), String("altgr_r"), String("ctrl"), String("ctrl_r"), String("menu"), String("esc"), String("1"), String("2"), String("3"), String("4"), String("5"), String("6"), String("7"), String("8"), String("9"), String("0"), String("minus"), String("equal"), String("backspace"), String("tab"), String("q"), String("w"), String("e"), String("r"), String("t"), String("y"), String("u"), String("i"), String("o"), String("p"), String("bracket_left"), String("bracket_right"), String("ret"), String("a"), String("s"), String("d"), String("f"), String("g"), String("h"), String("j"), String("k"), String("l"), String("semicolon"), String("apostrophe"), String("grave_accent"), String("backslash"), String("z"), String("x"), String("c"), String("v"), String("b"), String("n"), String("m"), String("comma"), String("dot"), String("slash"), String("asterisk"), String("spc"), String("caps_lock"), String("f1"), String("f2"), String("f3"), String("f4"), String("f5"), String("f6"), String("f7"), String("f8"), String("f9"), String("f10"), String("num_lock"), String("scroll_lock"), String("kp_divide"), String("kp_multiply"), String("kp_subtract"), String("kp_add"), String("kp_enter"), String("kp_decimal"), String("sysrq"), String("kp_0"), String("kp_1"), String("kp_2"), String("kp_3"), String("kp_4"), String("kp_5"), String("kp_6"), String("kp_7"), String("kp_8"), String("kp_9"), String("less"), String("f11"), String("f12"), String("print"), String("home"), String("pgup"), String("pgdn"), String("end"), String("left"), String("up"), String("down"), String("right"), String("insert"), String("delete"), String("stop"), String("again"), String("props"), String("undo"), String("front"), String("copy"), String("open"), String("paste"), String("find"), String("cut"), String("lf"), String("help"), String("meta_l"), String("meta_r"), String("compose"), String("pause")]) }) }, Section { description: ["#", " @KeyValue", "", " Represents a keyboard key.", "", " Since: 1.3.0", "#"], qemu_type: Union(Union { name: "KeyValue", discriminator: Null, data: Object({"number": String("int"), "qcode": String("QKeyCode")}) }) }, Section { description: ["#", " @send-key:", "", " Send keys to guest.", "", " @keys: An array of @KeyValue elements. All @KeyValues in this array are", "        simultaneously sent to the guest. A @KeyValue.number value is sent", "        directly to the guest, while @KeyValue.qcode must be a valid", "        @QKeyCode value", "", " @hold-time: #optional time to delay key up events, milliseconds. Defaults", "             to 100", "", " Returns: Nothing on success", "          If key is unknown or redundant, InvalidParameter", "", " Since: 1.3.0", "", "#"], qemu_type: Command(Command { name: "send-key", fields: Object({"*hold-time": String("int"), "keys": Array([String("KeyValue")])}), gen: Null, returns: Null }) }, Section { description: ["#", " @screendump:", "", " Write a PPM of the VGA screen to a file.", "", " @filename: the path of a new PPM file to store the image", "", " Returns: Nothing on success", "", " Since: 0.14.0", "#"], qemu_type: Command(Command { name: "screendump", fields: Object({"filename": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @ChardevFile:", "", " Configuration info for file chardevs.", "", " @in:  #optional The name of the input file", " @out: The name of the output file", "", " Since: 1.4", "#"], qemu_type: Struct(Struct { name: "ChardevFile", fields: Object({"*in": String("str"), "out": String("str")}), base: Null }) }, Section { description: ["#", " @ChardevHostdev:", "", " Configuration info for device and pipe chardevs.", "", " @device: The name of the special file for the device,", "          i.e. /dev/ttyS0 on Unix or COM1: on Windows", " @type: What kind of device this is.", "", " Since: 1.4", "#"], qemu_type: Struct(Struct { name: "ChardevHostdev", fields: Object({"device": String("str")}), base: Null }) }, Section { description: ["#", " @ChardevSocket:", "", " Configuration info for (stream) socket chardevs.", "", " @addr: socket address to listen on (server=true)", "        or connect to (server=false)", " @server: #optional create server socket (default: true)", " @wait: #optional wait for incoming connection on server", "        sockets (default: false).", " @nodelay: #optional set TCP_NODELAY socket option (default: false)", " @telnet: #optional enable telnet protocol on server", "          sockets (default: false)", " @reconnect: #optional For a client socket, if a socket is disconnected,", "          then attempt a reconnect after the given number of seconds.", "          Setting this to zero disables this function. (default: 0)", "          (Since: 2.2)", "", " Since: 1.4", "#"], qemu_type: Struct(Struct { name: "ChardevSocket", fields: Object({"*nodelay": String("bool"), "*reconnect": String("int"), "*server": String("bool"), "*telnet": String("bool"), "*wait": String("bool"), "addr": String("SocketAddress")}), base: Null }) }, Section { description: ["#", " @ChardevUdp:", "", " Configuration info for datagram socket chardevs.", "", " @remote: remote address", " @local: #optional local address", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "ChardevUdp", fields: Object({"*local": String("SocketAddress"), "remote": String("SocketAddress")}), base: Null }) }, Section { description: ["#", " @ChardevMux:", "", " Configuration info for mux chardevs.", "", " @chardev: name of the base chardev.", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "ChardevMux", fields: Object({"chardev": String("str")}), base: Null }) }, Section { description: ["#", " @ChardevStdio:", "", " Configuration info for stdio chardevs.", "", " @signal: #optional Allow signals (such as SIGINT triggered by ^C)", "          be delivered to qemu.  Default: true in -nographic mode,", "          false otherwise.", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "ChardevStdio", fields: Object({"*signal": String("bool")}), base: Null }) }, Section { description: ["#", " @ChardevSpiceChannel:", "", " Configuration info for spice vm channel chardevs.", "", " @type: kind of channel (for example vdagent).", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "ChardevSpiceChannel", fields: Object({"type": String("str")}), base: Null }) }, Section { description: ["#", " @ChardevSpicePort:", "", " Configuration info for spice port chardevs.", "", " @fqdn: name of the channel (see docs/spice-port-fqdn.txt)", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "ChardevSpicePort", fields: Object({"fqdn": String("str")}), base: Null }) }, Section { description: ["#", " @ChardevVC:", "", " Configuration info for virtual console chardevs.", "", " @width:  console width,  in pixels", " @height: console height, in pixels", " @cols:   console width,  in chars", " @rows:   console height, in chars", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "ChardevVC", fields: Object({"*cols": String("int"), "*height": String("int"), "*rows": String("int"), "*width": String("int")}), base: Null }) }, Section { description: ["#", " @ChardevRingbuf:", "", " Configuration info for ring buffer chardevs.", "", " @size: #optional ring buffer size, must be power of two, default is 65536", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "ChardevRingbuf", fields: Object({"*size": String("int")}), base: Null }) }, Section { description: ["#", " @ChardevBackend:", "", " Configuration info for the new chardev backend.", "", " Since: 1.4 (testdev since 2.2)", "#"], qemu_type: Struct(Struct { name: "ChardevDummy", fields: Object({}), base: Null }) }, Section { description: [], qemu_type: Union(Union { name: "ChardevBackend", discriminator: Null, data: Object({"braille": String("ChardevDummy"), "console": String("ChardevDummy"), "file": String("ChardevFile"), "memory": String("ChardevRingbuf"), "msmouse": String("ChardevDummy"), "mux": String("ChardevMux"), "null": String("ChardevDummy"), "parallel": String("ChardevHostdev"), "pipe": String("ChardevHostdev"), "pty": String("ChardevDummy"), "ringbuf": String("ChardevRingbuf"), "serial": String("ChardevHostdev"), "socket": String("ChardevSocket"), "spiceport": String("ChardevSpicePort"), "spicevmc": String("ChardevSpiceChannel"), "stdio": String("ChardevStdio"), "testdev": String("ChardevDummy"), "udp": String("ChardevUdp"), "vc": String("ChardevVC")}) }) }, Section { description: ["#", " @ChardevReturn:", "", " Return info about the chardev backend just created.", "", " @pty: #optional name of the slave pseudoterminal device, present if", "       and only if a chardev of type \"pty\" was created", "", " Since: 1.4", "#"], qemu_type: Struct(Struct { name: "ChardevReturn", fields: Object({"*pty": String("str")}), base: Null }) }, Section { description: ["#", " @chardev-add:", "", " Add a character device backend", "", " @id: the chardev\"s ID, must be unique", " @backend: backend type and parameters", "", " Returns: ChardevReturn.", "", " Since: 1.4", "#"], qemu_type: Command(Command { name: "chardev-add", fields: Object({"backend": String("ChardevBackend"), "id": String("str")}), gen: Null, returns: String("ChardevReturn") }) }, Section { description: ["#", " @chardev-remove:", "", " Remove a character device backend", "", " @id: the chardev\"s ID, must exist and not be in use", "", " Returns: Nothing on success", "", " Since: 1.4", "#"], qemu_type: Command(Command { name: "chardev-remove", fields: Object({"id": String("str")}), gen: Null, returns: Null }) }, Section { description: ["#", " @TpmModel:", "", " An enumeration of TPM models", "", " @tpm-tis: TPM TIS model", "", " Since: 1.5", "#"], qemu_type: Enum(Enum { name: "TpmModel", fields: Array([String("tpm-tis")]) }) }, Section { description: ["#", " @query-tpm-models:", "", " Return a list of supported TPM models", "", " Returns: a list of TpmModel", "", " Since: 1.5", "#"], qemu_type: Command(Command { name: "query-tpm-models", fields: Null, gen: Null, returns: Array([String("TpmModel")]) }) }, Section { description: ["#", " @TpmType:", "", " An enumeration of TPM types", "", " @passthrough: TPM passthrough type", "", " Since: 1.5", "#"], qemu_type: Enum(Enum { name: "TpmType", fields: Array([String("passthrough")]) }) }, Section { description: ["#", " @query-tpm-types:", "", " Return a list of supported TPM types", "", " Returns: a list of TpmType", "", " Since: 1.5", "#"], qemu_type: Command(Command { name: "query-tpm-types", fields: Null, gen: Null, returns: Array([String("TpmType")]) }) }, Section { description: ["#", " @TPMPassthroughOptions:", "", " Information about the TPM passthrough type", "", " @path: #optional string describing the path used for accessing the TPM device", "", " @cancel-path: #optional string showing the TPM\"s sysfs cancel file", "               for cancellation of TPM commands while they are executing", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "TPMPassthroughOptions", fields: Object({"*cancel-path": String("str"), "*path": String("str")}), base: Null }) }, Section { description: ["#", " @TpmTypeOptions:", "", " A union referencing different TPM backend types\" configuration options", "", " @passthrough: The configuration options for the TPM passthrough type", "", " Since: 1.5", "#"], qemu_type: Union(Union { name: "TpmTypeOptions", discriminator: Null, data: Object({"passthrough": String("TPMPassthroughOptions")}) }) }, Section { description: ["#", " @TpmInfo:", "", " Information about the TPM", "", " @id: The Id of the TPM", "", " @model: The TPM frontend model", "", " @options: The TPM (backend) type configuration options", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "TPMInfo", fields: Object({"id": String("str"), "model": String("TpmModel"), "options": String("TpmTypeOptions")}), base: Null }) }, Section { description: ["#", " @query-tpm:", "", " Return information about the TPM device", "", " Returns: @TPMInfo on success", "", " Since: 1.5", "#"], qemu_type: Command(Command { name: "query-tpm", fields: Null, gen: Null, returns: Array([String("TPMInfo")]) }) }, Section { description: ["#", " @AcpiTableOptions", "", " Specify an ACPI table on the command line to load.", "", " At most one of @file and @data can be specified. The list of files specified", " by any one of them is loaded and concatenated in order. If both are omitted,", " @data is implied.", "", " Other fields / optargs can be used to override fields of the generic ACPI", " table header; refer to the ACPI specification 5.0, section 5.2.6 System", " Description Table Header. If a header field is not overridden, then the", " corresponding value from the concatenated blob is used (in case of @file), or", " it is filled in with a hard-coded value (in case of @data).", "", " String fields are copied into the matching ACPI member from lowest address", " upwards, and silently truncated / NUL-padded to length.", "", " @sig: #optional table signature / identifier (4 bytes)", "", " @rev: #optional table revision number (dependent on signature, 1 byte)", "", " @oem_id: #optional OEM identifier (6 bytes)", "", " @oem_table_id: #optional OEM table identifier (8 bytes)", "", " @oem_rev: #optional OEM-supplied revision number (4 bytes)", "", " @asl_compiler_id: #optional identifier of the utility that created the table", "                   (4 bytes)", "", " @asl_compiler_rev: #optional revision number of the utility that created the", "                    table (4 bytes)", "", " @file: #optional colon (:) separated list of pathnames to load and", "        concatenate as table data. The resultant binary blob is expected to", "        have an ACPI table header. At least one file is required. This field", "        excludes @data.", "", " @data: #optional colon (:) separated list of pathnames to load and", "        concatenate as table data. The resultant binary blob must not have an", "        ACPI table header. At least one file is required. This field excludes", "        @file.", "", " Since 1.5", "#"], qemu_type: Struct(Struct { name: "AcpiTableOptions", fields: Object({"*asl_compiler_id": String("str"), "*asl_compiler_rev": String("uint32"), "*data": String("str"), "*file": String("str"), "*oem_id": String("str"), "*oem_rev": String("uint32"), "*oem_table_id": String("str"), "*rev": String("uint8"), "*sig": String("str")}), base: Null }) }, Section { description: ["#", " @CommandLineParameterType:", "", " Possible types for an option parameter.", "", " @string: accepts a character string", "", " @boolean: accepts \"on\" or \"off\"", "", " @number: accepts a number", "", " @size: accepts a number followed by an optional suffix (K)ilo,", "        (M)ega, (G)iga, (T)era", "", " Since 1.5", "#"], qemu_type: Enum(Enum { name: "CommandLineParameterType", fields: Array([String("string"), String("boolean"), String("number"), String("size")]) }) }, Section { description: ["#", " @CommandLineParameterInfo:", "", " Details about a single parameter of a command line option.", "", " @name: parameter name", "", " @type: parameter @CommandLineParameterType", "", " @help: #optional human readable text string, not suitable for parsing.", "", " @default: #optional default value string (since 2.1)", "", " Since 1.5", "#"], qemu_type: Struct(Struct { name: "CommandLineParameterInfo", fields: Object({"*default": String("str"), "*help": String("str"), "name": String("str"), "type": String("CommandLineParameterType")}), base: Null }) }, Section { description: ["#", " @CommandLineOptionInfo:", "", " Details about a command line option, including its list of parameter details", "", " @option: option name", "", " @parameters: an array of @CommandLineParameterInfo", "", " Since 1.5", "#"], qemu_type: Struct(Struct { name: "CommandLineOptionInfo", fields: Object({"option": String("str"), "parameters": Array([String("CommandLineParameterInfo")])}), base: Null }) }, Section { description: ["#", " @query-command-line-options:", "", " Query command line option schema.", "", " @option: #optional option name", "", " Returns: list of @CommandLineOptionInfo for all options (or for the given", "          @option).  Returns an error if the given @option doesn\"t exist.", "", " Since 1.5", "#"], qemu_type: Command(Command { name: "query-command-line-options", fields: Object({"*option": String("str")}), gen: Null, returns: Array([String("CommandLineOptionInfo")]) }) }, Section { description: ["#", " @X86CPURegister32", "", " A X86 32-bit register", "", " Since: 1.5", "#"], qemu_type: Enum(Enum { name: "X86CPURegister32", fields: Array([String("EAX"), String("EBX"), String("ECX"), String("EDX"), String("ESP"), String("EBP"), String("ESI"), String("EDI")]) }) }, Section { description: ["#", " @X86CPUFeatureWordInfo", "", " Information about a X86 CPU feature word", "", " @cpuid-input-eax: Input EAX value for CPUID instruction for that feature word", "", " @cpuid-input-ecx: #optional Input ECX value for CPUID instruction for that", "                   feature word", "", " @cpuid-register: Output register containing the feature bits", "", " @features: value of output register, containing the feature bits", "", " Since: 1.5", "#"], qemu_type: Struct(Struct { name: "X86CPUFeatureWordInfo", fields: Object({"*cpuid-input-ecx": String("int"), "cpuid-input-eax": String("int"), "cpuid-register": String("X86CPURegister32"), "features": String("int")}), base: Null }) }, Section { description: ["#", " @RxState:", "", " Packets receiving state", "", " @normal: filter assigned packets according to the mac-table", "", " @none: don\"t receive any assigned packet", "", " @all: receive all assigned packets", "", " Since: 1.6", "#"], qemu_type: Enum(Enum { name: "RxState", fields: Array([String("normal"), String("none"), String("all")]) }) }, Section { description: ["#", " @RxFilterInfo:", "", " Rx-filter information for a NIC.", "", " @name: net client name", "", " @promiscuous: whether promiscuous mode is enabled", "", " @multicast: multicast receive state", "", " @unicast: unicast receive state", "", " @vlan: vlan receive state (Since 2.0)", "", " @broadcast-allowed: whether to receive broadcast", "", " @multicast-overflow: multicast table is overflowed or not", "", " @unicast-overflow: unicast table is overflowed or not", "", " @main-mac: the main macaddr string", "", " @vlan-table: a list of active vlan id", "", " @unicast-table: a list of unicast macaddr string", "", " @multicast-table: a list of multicast macaddr string", "", " Since 1.6", "#"], qemu_type: Struct(Struct { name: "RxFilterInfo", fields: Object({"broadcast-allowed": String("bool"), "main-mac": String("str"), "multicast": String("RxState"), "multicast-overflow": String("bool"), "multicast-table": Array([String("str")]), "name": String("str"), "promiscuous": String("bool"), "unicast": String("RxState"), "unicast-overflow": String("bool"), "unicast-table": Array([String("str")]), "vlan": String("RxState"), "vlan-table": Array([String("int")])}), base: Null }) }, Section { description: ["#", " @query-rx-filter:", "", " Return rx-filter information for all NICs (or for the given NIC).", "", " @name: #optional net client name", "", " Returns: list of @RxFilterInfo for all NICs (or for the given NIC).", "          Returns an error if the given @name doesn\"t exist, or given", "          NIC doesn\"t support rx-filter querying, or given net client", "          isn\"t a NIC.", "", " Since: 1.6", "#"], qemu_type: Command(Command { name: "query-rx-filter", fields: Object({"*name": String("str")}), gen: Null, returns: Array([String("RxFilterInfo")]) }) }, Section { description: ["#", " @InputButton", "", " Button of a pointer input device (mouse, tablet).", "", " Since: 2.0", "#"], qemu_type: Enum(Enum { name: "InputButton", fields: Array([String("Left"), String("Middle"), String("Right"), String("WheelUp"), String("WheelDown")]) }) }, Section { description: ["#", " @InputButton", "", " Position axis of a pointer input device (mouse, tablet).", "", " Since: 2.0", "#"], qemu_type: Enum(Enum { name: "InputAxis", fields: Array([String("X"), String("Y")]) }) }, Section { description: ["#", " @InputKeyEvent", "", " Keyboard input event.", "", " @key:    Which key this event is for.", " @down:   True for key-down and false for key-up events.", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "InputKeyEvent", fields: Object({"down": String("bool"), "key": String("KeyValue")}), base: Null }) }, Section { description: ["#", " @InputBtnEvent", "", " Pointer button input event.", "", " @button: Which button this event is for.", " @down:   True for key-down and false for key-up events.", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "InputBtnEvent", fields: Object({"button": String("InputButton"), "down": String("bool")}), base: Null }) }, Section { description: ["#", " @InputMoveEvent", "", " Pointer motion input event.", "", " @axis:   Which axis is referenced by @value.", " @value:  Pointer position.  For absolute coordinates the", "          valid range is 0 -> 0x7ffff", "", " Since: 2.0", "#"], qemu_type: Struct(Struct { name: "InputMoveEvent", fields: Object({"axis": String("InputAxis"), "value": String("int")}), base: Null }) }, Section { description: ["#", " @InputEvent", "", " Input event union.", "", " @key: Input event of Keyboard", " @btn: Input event of pointer buttons", " @rel: Input event of relative pointer motion", " @abs: Input event of absolute pointer motion", "", " Since: 2.0", "#"], qemu_type: Union(Union { name: "InputEvent", discriminator: Null, data: Object({"abs": String("InputMoveEvent"), "btn": String("InputBtnEvent"), "key": String("InputKeyEvent"), "rel": String("InputMoveEvent")}) }) }, Section { description: ["#", " @x-input-send-event", "", " Send input event(s) to guest.", "", " @console: #optional console to send event(s) to.", "           This parameter can be used to send the input event to", "           specific input devices in case (a) multiple input devices", "           of the same kind are added to the virtual machine and (b)", "           you have configured input routing (see docs/multiseat.txt)", "           for those input devices.  If input routing is not", "           configured this parameter has no effect.", "           If @console is missing, only devices that aren\"t associated", "           with a console are admissible.", "           If @console is specified, it must exist, and both devices", "           associated with that console and devices not associated with a", "           console are admissible, but the former take precedence."], qemu_type: Command(Command { name: "x-input-send-event", fields: Object({"*console": String("int"), "events": Array([String("InputEvent")])}), gen: Null, returns: Null }) }, Section { description: ["#", " @NumaOptions", "", " A discriminated record of NUMA options. (for OptsVisitor)", "", " Since 2.1", "#"], qemu_type: Union(Union { name: "NumaOptions", discriminator: Null, data: Object({"node": String("NumaNodeOptions")}) }) }, Section { description: ["#", " @NumaNodeOptions", "", " Create a guest NUMA node. (for OptsVisitor)", "", " @nodeid: #optional NUMA node ID (increase by 1 from 0 if omitted)", "", " @cpus: #optional VCPUs belonging to this node (assign VCPUS round-robin", "         if omitted)", "", " @mem: #optional memory size of this node; mutually exclusive with @memdev.", "       Equally divide total memory among nodes if both @mem and @memdev are", "       omitted.", "", " @memdev: #optional memory backend object.  If specified for one node,", "          it must be specified for all nodes.", "", " Since: 2.1", "#"], qemu_type: Struct(Struct { name: "NumaNodeOptions", fields: Object({"*cpus": Array([String("uint16")]), "*mem": String("size"), "*memdev": String("str"), "*nodeid": String("uint16")}), base: Null }) }, Section { description: ["#", " @HostMemPolicy", "", " Host memory policy types", "", " @default: restore default policy, remove any nondefault policy", "", " @preferred: set the preferred host nodes for allocation", "", " @bind: a strict policy that restricts memory allocation to the", "        host nodes specified", "", " @interleave: memory allocations are interleaved across the set", "              of host nodes specified", "", " Since 2.1", "#"], qemu_type: Enum(Enum { name: "HostMemPolicy", fields: Array([String("default"), String("preferred"), String("bind"), String("interleave")]) }) }, Section { description: ["#", " @Memdev:", "", " Information about memory backend", "", " @size: memory backend size", "", " @merge: enables or disables memory merge support", "", " @dump: includes memory backend\"s memory in a core dump or not", "", " @prealloc: enables or disables memory preallocation", "", " @host-nodes: host nodes for its memory policy", "", " @policy: memory policy of memory backend", "", " Since: 2.1", "#"], qemu_type: Struct(Struct { name: "Memdev", fields: Object({"dump": String("bool"), "host-nodes": Array([String("uint16")]), "merge": String("bool"), "policy": String("HostMemPolicy"), "prealloc": String("bool"), "size": String("size")}), base: Null }) }, Section { description: ["#", " @query-memdev:", "", " Returns information for all memory backends.", "", " Returns: a list of @Memdev.", "", " Since: 2.1", "#"], qemu_type: Command(Command { name: "query-memdev", fields: Null, gen: Null, returns: Array([String("Memdev")]) }) }, Section { description: ["#", " @PCDIMMDeviceInfo:", "", " PCDIMMDevice state information", "", " @id: #optional device\"s ID", "", " @addr: physical address, where device is mapped", "", " @size: size of memory that the device provides", "", " @slot: slot number at which device is plugged in", "", " @node: NUMA node number where device is plugged in", "", " @memdev: memory backend linked with device", "", " @hotplugged: true if device was hotplugged", "", " @hotpluggable: true if device if could be added/removed while machine is running", "", " Since: 2.1", "#"], qemu_type: Struct(Struct { name: "PCDIMMDeviceInfo", fields: Object({"*id": String("str"), "addr": String("int"), "hotpluggable": String("bool"), "hotplugged": String("bool"), "memdev": String("str"), "node": String("int"), "size": String("int"), "slot": String("int")}), base: Null }) }, Section { description: ["#", " @MemoryDeviceInfo:", "", " Union containing information about a memory device", "", " Since: 2.1", "#"], qemu_type: Union(Union { name: "MemoryDeviceInfo", discriminator: Null, data: Object({"dimm": String("PCDIMMDeviceInfo")}) }) }, Section { description: ["#", " @query-memory-devices", "", " Lists available memory devices and their state", "", " Since: 2.1", "#"], qemu_type: Command(Command { name: "query-memory-devices", fields: Null, gen: Null, returns: Array([String("MemoryDeviceInfo")]) }) }, Section { description: ["# @ACPISlotType", "", " @DIMM: memory slot", ""], qemu_type: Enum(Enum { name: "ACPISlotType", fields: Array([String("DIMM")]) }) }, Section { description: ["# @ACPIOSTInfo", "", " OSPM Status Indication for a device", " For description of possible values of @source and @status fields", " see \"_OST (OSPM Status Indication)\" chapter of ACPI5.0 spec.", "", " @device: #optional device ID associated with slot", "", " @slot: slot ID, unique per slot of a given @slot-type", "", " @slot-type: type of the slot", "", " @source: an integer containing the source event", "", " @status: an integer containing the status code", "", " Since: 2.1", "#"], qemu_type: Struct(Struct { name: "ACPIOSTInfo", fields: Object({"*device": String("str"), "slot": String("str"), "slot-type": String("ACPISlotType"), "source": String("int"), "status": String("int")}), base: Null }) }, Section { description: ["#", " @query-acpi-ospm-status", "", " Lists ACPI OSPM status of ACPI device objects,", " which might be reported via _OST method", "", " Since: 2.1", "#"], qemu_type: Command(Command { name: "query-acpi-ospm-status", fields: Null, gen: Null, returns: Array([String("ACPIOSTInfo")]) }) }, Section { description: ["#", " @WatchdogExpirationAction", "", " An enumeration of the actions taken when the watchdog device\"s timer is", " expired", "", " @reset: system resets", "", " @shutdown: system shutdown, note that it is similar to @powerdown, which", "            tries to set to system status and notify guest", "", " @poweroff: system poweroff, the emulator program exits", "", " @pause: system pauses, similar to @stop", "", " @debug: system enters debug state", "", " @none: nothing is done", "", " Since: 2.1", "#"], qemu_type: Enum(Enum { name: "WatchdogExpirationAction", fields: Array([String("reset"), String("shutdown"), String("poweroff"), String("pause"), String("debug"), String("none")]) }) }, Section { description: ["#", " @IoOperationType", "", " An enumeration of the I/O operation types", "", " @read: read operation", "", " @write: write operation", "", " Since: 2.1", "#"], qemu_type: Enum(Enum { name: "IoOperationType", fields: Array([String("read"), String("write")]) }) }, Section { description: ["#", " @GuestPanicAction", "", " An enumeration of the actions taken when guest OS panic is detected", "", " @pause: system pauses", "", " Since: 2.1", "#"], qemu_type: Enum(Enum { name: "GuestPanicAction", fields: Array([String("pause")]) }) }, Section { description: ["#", " @rtc-reset-reinjection", "", " This command will reset the RTC interrupt reinjection backlog.", " Can be used if another mechanism to synchronize guest time", " is in effect, for example QEMU guest agent\"s guest-set-time", " command.", "", " Since: 2.1", "#"], qemu_type: Command(Command { name: "rtc-reset-reinjection", fields: Null, gen: Null, returns: Null }) }]
kablam! 
kablam! --- stderr
kablam! thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error { repr: Os { code: 30, message: "Read-only file system" } }', /buildslave/rust-buildbot/slave/stable-dist-rustc-linux/build/src/libcore/result.rs:868
kablam! note: Run with `RUST_BACKTRACE=1` for a backtrace.
kablam! 
boom! running `docker rm -f 99041e924a99ae69f35f07e9aa57c2676e33485db11ba731f3d465a919f3b22c`
blam! 99041e924a99ae69f35f07e9aa57c2676e33485db11ba731f3d465a919f3b22c
